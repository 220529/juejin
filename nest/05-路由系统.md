# NestJS æºç è§£æï¼šè·¯ç”±ç³»ç»Ÿ

> æ·±å…¥ RouterExplorer å’Œ RouterExecutionContextï¼Œæ­ç§˜è¯·æ±‚çš„åˆ†å‘ä¸å¤„ç†ã€‚

## è·¯ç”±æ³¨å†Œæµç¨‹

```
NestApplication.listen()
        â†“
RoutesResolver.resolve()
        â†“
RouterExplorer.explore()
        â†“
HttpAdapter.bindHandler()
```

## RoutesResolver

è§£ææ‰€æœ‰æ§åˆ¶å™¨çš„è·¯ç”±ï¼š

```typescript
// packages/core/router/routes-resolver.ts
export class RoutesResolver {
  public resolve(applicationRef: HttpServer, globalPrefix: string) {
    const modules = this.container.getModules();

    modules.forEach(({ controllers, metatype }, moduleName) => {
      // è·å–æ¨¡å—è·¯å¾„å‰ç¼€
      const modulePath = this.getModulePathMetadata(metatype);

      // éå†æ§åˆ¶å™¨
      controllers.forEach((wrapper, token) => {
        const { instance, metatype } = wrapper;

        // è·å–æ§åˆ¶å™¨è·¯å¾„
        const paths = this.routerExplorer.extractRouterPath(metatype);
        const host = this.getHostMetadata(metatype);

        // æ¢ç´¢å¹¶æ³¨å†Œè·¯ç”±
        paths.forEach(path => {
          this.routerExplorer.explore(
            wrapper,
            moduleName,
            applicationRef,
            host,
            {
              ctrlPath: path,
              modulePath,
              globalPrefix,
            },
          );
        });
      });
    });
  }
}
```

## RouterExplorer

æ¢ç´¢æ§åˆ¶å™¨çš„è·¯ç”±æ–¹æ³•ï¼š

```typescript
// packages/core/router/router-explorer.ts
export class RouterExplorer {
  public explore(
    instanceWrapper: InstanceWrapper,
    moduleKey: string,
    httpAdapterRef: HttpServer,
    host: string | RegExp | Array<string | RegExp>,
    routePathMetadata: RoutePathMetadata,
  ) {
    const { instance } = instanceWrapper;

    // æ‰«ææ‰€æœ‰è·¯ç”±æ–¹æ³•
    const routerPaths = this.pathsExplorer.scanForPaths(instance);

    // æ³¨å†Œåˆ° HTTP é€‚é…å™¨
    this.applyPathsToRouterProxy(
      httpAdapterRef,
      routerPaths,
      instanceWrapper,
      moduleKey,
      routePathMetadata,
      host,
    );
  }

  // æ³¨å†Œè·¯ç”±
  public applyPathsToRouterProxy(
    router: HttpServer,
    routeDefinitions: RouteDefinition[],
    instanceWrapper: InstanceWrapper,
    moduleKey: string,
    routePathMetadata: RoutePathMetadata,
    host: string | RegExp | Array<string | RegExp>,
  ) {
    routeDefinitions.forEach(routeDefinition => {
      this.applyCallbackToRouter(
        router,
        routeDefinition,
        instanceWrapper,
        moduleKey,
        routePathMetadata,
        host,
      );
    });
  }

  // ç»‘å®šå¤„ç†å‡½æ•°
  private applyCallbackToRouter(
    router: HttpServer,
    routeDefinition: RouteDefinition,
    instanceWrapper: InstanceWrapper,
    moduleKey: string,
    routePathMetadata: RoutePathMetadata,
    host: string | RegExp | Array<string | RegExp>,
  ) {
    const { path, requestMethod, targetCallback, methodName } = routeDefinition;

    // åˆ›å»ºæ‰§è¡Œä¸Šä¸‹æ–‡
    const executionContext = this.executionContextCreator.create(
      instanceWrapper,
      targetCallback,
      methodName,
      moduleKey,
      requestMethod,
    );

    // åˆ›å»ºä»£ç†å¤„ç†å‡½æ•°
    const proxy = this.createCallbackProxy(
      instanceWrapper,
      executionContext,
      methodName,
      moduleKey,
      requestMethod,
    );

    // æ„å»ºå®Œæ•´è·¯å¾„
    const fullPath = this.routePathFactory.create(routePathMetadata, requestMethod);

    // æ³¨å†Œåˆ°è·¯ç”±å™¨
    this.routerMethodFactory
      .get(router, requestMethod)
      .call(router, fullPath, proxy);

    this.logger.log(ROUTE_MAPPED_MESSAGE(fullPath, requestMethod));
  }
}
```

## RouterExecutionContext

åˆ›å»ºè·¯ç”±æ‰§è¡Œä¸Šä¸‹æ–‡ï¼š

```typescript
// packages/core/router/router-execution-context.ts
export class RouterExecutionContext {
  public create(
    instance: Controller,
    callback: (...args: any[]) => unknown,
    methodName: string,
    moduleKey: string,
    requestMethod: RequestMethod,
  ) {
    // è·å–å‚æ•°å…ƒæ•°æ®
    const argsMetadata = this.getArgumentsMetadata(callback, methodName);

    // è·å–ç®¡é“
    const pipes = this.pipesContextCreator.create(instance, callback, moduleKey);

    // è·å–å®ˆå«
    const guards = this.guardsContextCreator.create(instance, callback, moduleKey);

    // è·å–æ‹¦æˆªå™¨
    const interceptors = this.interceptorsContextCreator.create(
      instance,
      callback,
      moduleKey,
    );

    // åˆ›å»ºå‚æ•°è§£æå™¨
    const paramsFactory = this.createParamsFactory(argsMetadata, pipes);

    // è¿”å›æ‰§è¡Œå‡½æ•°
    return this.createHandlerProxy(
      instance,
      callback,
      methodName,
      paramsFactory,
      guards,
      interceptors,
    );
  }
}
```

## è¯·æ±‚å¤„ç†æµç¨‹

```
Request
   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. Guards (å®ˆå«)                    â”‚
â”‚    canActivate() â†’ true/false       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. Interceptors (æ‹¦æˆªå™¨ - before)   â”‚
â”‚    intercept() â†’ Observable         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. Pipes (ç®¡é“)                     â”‚
â”‚    transform() â†’ value              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. Route Handler (è·¯ç”±å¤„ç†å™¨)       â”‚
â”‚    controller.method()              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 5. Interceptors (æ‹¦æˆªå™¨ - after)    â”‚
â”‚    Observable.pipe()                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 6. Exception Filters (å¼‚å¸¸è¿‡æ»¤å™¨)   â”‚
â”‚    catch() â†’ response               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â†“
Response
```

## GuardsConsumer

æ‰§è¡Œå®ˆå«ï¼š

```typescript
// packages/core/guards/guards-consumer.ts
export class GuardsConsumer {
  public async tryActivate(
    guards: CanActivate[],
    args: unknown[],
    instance: Controller,
    callback: (...args: unknown[]) => unknown,
    type?: string,
  ): Promise<boolean> {
    if (!guards || isEmpty(guards)) {
      return true;
    }

    const context = this.createContext(args, instance, callback);
    context.setType(type);

    // ä¾æ¬¡æ‰§è¡Œå®ˆå«
    for (const guard of guards) {
      const result = guard.canActivate(context);

      // å¤„ç†åŒæ­¥/å¼‚æ­¥/Observable ç»“æœ
      if (typeof result === 'boolean') {
        if (!result) return false;
        continue;
      }

      if (await this.pickResult(result)) {
        continue;
      }
      return false;
    }
    return true;
  }
}
```

## InterceptorsConsumer

æ‰§è¡Œæ‹¦æˆªå™¨ï¼š

```typescript
// packages/core/interceptors/interceptors-consumer.ts
export class InterceptorsConsumer {
  public async intercept(
    interceptors: NestInterceptor[],
    args: unknown[],
    instance: Controller,
    callback: (...args: unknown[]) => unknown,
    next: () => Promise<unknown>,
    type?: string,
  ): Promise<unknown> {
    if (isEmpty(interceptors)) {
      return next();
    }

    const context = this.createContext(args, instance, callback);
    context.setType(type);

    // æ„å»ºæ‹¦æˆªå™¨é“¾
    const nextFn = async (i = 0) => {
      if (i >= interceptors.length) {
        return defer(() => this.transformDeferred(next));
      }

      const handler: CallHandler = {
        handle: () => defer(() => nextFn(i + 1)).pipe(mergeAll()),
      };

      return interceptors[i].intercept(context, handler);
    };

    return defer(() => nextFn()).pipe(mergeAll());
  }
}
```

## PipesConsumer

æ‰§è¡Œç®¡é“ï¼š

```typescript
// packages/core/pipes/pipes-consumer.ts
export class PipesConsumer {
  public async apply(
    value: unknown,
    { metatype, type, data }: ArgumentMetadata,
    pipes: PipeTransform[],
  ) {
    return this.applyPipes(value, { metatype, type, data }, pipes);
  }

  public async applyPipes(
    value: unknown,
    metadata: { metatype: any; type?: any; data?: any },
    transforms: PipeTransform[],
  ) {
    // ä¾æ¬¡æ‰§è¡Œç®¡é“
    return transforms.reduce(async (deferredValue, pipe) => {
      const val = await deferredValue;
      const result = pipe.transform(val, metadata);
      return result;
    }, Promise.resolve(value));
  }
}
```

## å‚æ•°è§£æ

### RouteParamsFactory

```typescript
// packages/core/router/route-params-factory.ts
export class RouteParamsFactory {
  public exchangeKeyForValue(
    key: RouteParamtypes,
    data: string | object | any,
    { req, res, next }: { req: any; res: any; next: Function },
  ) {
    switch (key) {
      case RouteParamtypes.REQUEST:
        return req;
      case RouteParamtypes.RESPONSE:
        return res;
      case RouteParamtypes.NEXT:
        return next;
      case RouteParamtypes.BODY:
        return data ? req.body?.[data] : req.body;
      case RouteParamtypes.PARAM:
        return data ? req.params?.[data] : req.params;
      case RouteParamtypes.QUERY:
        return data ? req.query?.[data] : req.query;
      case RouteParamtypes.HEADERS:
        return data ? req.headers?.[data.toLowerCase()] : req.headers;
      case RouteParamtypes.IP:
        return req.ip;
      case RouteParamtypes.HOST:
        return req.hostname;
      default:
        return null;
    }
  }
}
```

## å¼‚å¸¸å¤„ç†

### ExceptionsHandler

```typescript
// packages/core/exceptions/exceptions-handler.ts
export class ExceptionsHandler {
  public handle(
    exception: Error | HttpException | any,
    host: ArgumentsHost,
  ): void {
    // å°è¯•ä½¿ç”¨è‡ªå®šä¹‰è¿‡æ»¤å™¨
    for (const filter of this.filters) {
      if (this.isExceptionOfType(exception, filter.exceptionMetatypes)) {
        filter.func(exception, host);
        return;
      }
    }

    // ä½¿ç”¨é»˜è®¤å¤„ç†
    this.invokeCustomFilters(exception, host);
  }
}
```

## ç‰ˆæœ¬æ§åˆ¶

```typescript
@Controller({
  path: 'cats',
  version: '1',
})
export class CatsControllerV1 {}

@Controller({
  path: 'cats',
  version: '2',
})
export class CatsControllerV2 {}
```

ç‰ˆæœ¬è·¯ç”±å¤„ç†ï¼š

```typescript
// packages/core/router/router-explorer.ts
private applyVersionFilter(
  router: HttpServer,
  routePathMetadata: RoutePathMetadata,
  versioningOptions: VersioningOptions,
) {
  const version = routePathMetadata.methodVersion;

  if (versioningOptions.type === VersioningType.URI) {
    // URI ç‰ˆæœ¬ï¼š/v1/cats
    return this.routePathFactory.create(routePathMetadata, requestMethod);
  }

  if (versioningOptions.type === VersioningType.HEADER) {
    // Header ç‰ˆæœ¬ï¼šX-API-Version: 1
    return this.createVersionedHandler(version);
  }

  if (versioningOptions.type === VersioningType.MEDIA_TYPE) {
    // Media Type ç‰ˆæœ¬ï¼šAccept: application/json;v=1
    return this.createMediaTypeVersionedHandler(version);
  }
}
```

## æ€»ç»“

NestJS è·¯ç”±ç³»ç»Ÿçš„æ ¸å¿ƒï¼š

1. **RoutesResolver**ï¼šè§£ææ‰€æœ‰æ§åˆ¶å™¨çš„è·¯ç”±
2. **RouterExplorer**ï¼šæ¢ç´¢è·¯ç”±æ–¹æ³•ï¼Œæ³¨å†Œåˆ° HTTP é€‚é…å™¨
3. **RouterExecutionContext**ï¼šåˆ›å»ºæ‰§è¡Œä¸Šä¸‹æ–‡ï¼Œç»„è£…ç®¡é“
4. **è¯·æ±‚å¤„ç†ç®¡é“**ï¼šGuards â†’ Interceptors â†’ Pipes â†’ Handler â†’ Interceptors â†’ Filters
5. **å‚æ•°è§£æ**ï¼šRouteParamsFactory è§£æ @Bodyã€@Query ç­‰
6. **ç‰ˆæœ¬æ§åˆ¶**ï¼šæ”¯æŒ URIã€Headerã€Media Type ä¸‰ç§æ–¹å¼

ä¸‹ä¸€ç¯‡æˆ‘ä»¬å°†åˆ†æä¸­é—´ä»¶æœºåˆ¶çš„å®ç°ã€‚

---

> ğŸ“¦ æºç ä½ç½®ï¼š`packages/core/router/`
>
> ä¸‹ä¸€ç¯‡ï¼šNestJS ä¸­é—´ä»¶æœºåˆ¶
