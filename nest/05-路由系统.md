# NestJS æºç è§£æï¼šè·¯ç”±ç³»ç»Ÿ

> æ·±å…¥ RouterExplorer å’Œ RouterExecutionContextï¼Œæ­ç§˜è¯·æ±‚çš„åˆ†å‘ä¸å¤„ç†ã€‚

## è·¯ç”±æ³¨å†Œæµç¨‹

```
NestApplication.listen()
        â†“
RoutesResolver.resolve()
        â†“
RouterExplorer.explore()
        â†“
HttpAdapter.bindHandler()
```

## è¯·æ±‚ä½œç”¨åŸŸå¤„ç†

å½“æ§åˆ¶å™¨æˆ–å…¶ä¾èµ–æ˜¯è¯·æ±‚ä½œç”¨åŸŸæ—¶ï¼ŒNestJS ä¼šä¸ºæ¯ä¸ªè¯·æ±‚åˆ›å»ºæ–°å®ä¾‹ï¼š

```typescript
// packages/core/router/router-explorer.ts
private applyCallbackToRouter(...) {
  const isRequestScoped = !instanceWrapper.isDependencyTreeStatic();
  
  const proxy = isRequestScoped
    ? this.createRequestScopedHandler(/*...*/)  // è¯·æ±‚ä½œç”¨åŸŸ
    : this.createCallbackProxy(/*...*/);        // é™æ€ä½œç”¨åŸŸ
}

public createRequestScopedHandler(
  instanceWrapper: InstanceWrapper,
  requestMethod: RequestMethod,
  moduleRef: Module,
  moduleKey: string,
  methodName: string,
) {
  const { instance } = instanceWrapper;
  const collection = moduleRef.controllers;
  const isTreeDurable = instanceWrapper.isDependencyTreeDurable();

  return async <TRequest, TResponse>(req: TRequest, res: TResponse, next: () => void) => {
    try {
      // è·å–æˆ–åˆ›å»ºè¯·æ±‚ä¸Šä¸‹æ–‡ ID
      const contextId = this.getContextId(req, isTreeDurable);
      
      // ä¸ºå½“å‰è¯·æ±‚åŠ è½½æ§åˆ¶å™¨å®ä¾‹
      const contextInstance = await this.injector.loadPerContext(
        instance,
        moduleRef,
        collection,
        contextId,
      );
      
      // åˆ›å»ºå¹¶æ‰§è¡Œä»£ç†
      await this.createCallbackProxy(
        contextInstance,
        contextInstance[methodName],
        methodName,
        moduleKey,
        requestMethod,
        contextId,
        instanceWrapper.id,
      )(req, res, next);
    } catch (err) {
      // å¼‚å¸¸å¤„ç†...
    }
  };
}
```

å…³é”®ç‚¹ï¼š
- `isDependencyTreeStatic()` åˆ¤æ–­æ•´ä¸ªä¾èµ–æ ‘æ˜¯å¦éƒ½æ˜¯é™æ€çš„
- `isDependencyTreeDurable()` åˆ¤æ–­æ˜¯å¦æ˜¯æŒä¹…åŒ–ä½œç”¨åŸŸ
- `loadPerContext()` ä¸ºç‰¹å®šä¸Šä¸‹æ–‡åŠ è½½å®ä¾‹

## RoutesResolver

è§£ææ‰€æœ‰æ§åˆ¶å™¨çš„è·¯ç”±ï¼š

```typescript
// packages/core/router/routes-resolver.ts
export class RoutesResolver {
  public resolve(applicationRef: HttpServer, globalPrefix: string) {
    const modules = this.container.getModules();

    modules.forEach(({ controllers, metatype }, moduleName) => {
      // è·å–æ¨¡å—è·¯å¾„å‰ç¼€
      const modulePath = this.getModulePathMetadata(metatype);

      // éå†æ§åˆ¶å™¨
      controllers.forEach((wrapper, token) => {
        const { instance, metatype } = wrapper;

        // è·å–æ§åˆ¶å™¨è·¯å¾„
        const paths = this.routerExplorer.extractRouterPath(metatype);
        const host = this.getHostMetadata(metatype);

        // æ¢ç´¢å¹¶æ³¨å†Œè·¯ç”±
        paths.forEach(path => {
          this.routerExplorer.explore(
            wrapper,
            moduleName,
            applicationRef,
            host,
            {
              ctrlPath: path,
              modulePath,
              globalPrefix,
            },
          );
        });
      });
    });
  }
}
```

## RouterExplorer

æ¢ç´¢æ§åˆ¶å™¨çš„è·¯ç”±æ–¹æ³•ï¼š

```typescript
// packages/core/router/router-explorer.ts
export class RouterExplorer {
  public explore(
    instanceWrapper: InstanceWrapper,
    moduleKey: string,
    httpAdapterRef: HttpServer,
    host: string | RegExp | Array<string | RegExp>,
    routePathMetadata: RoutePathMetadata,
  ) {
    const { instance } = instanceWrapper;

    // æ‰«ææ‰€æœ‰è·¯ç”±æ–¹æ³•
    const routerPaths = this.pathsExplorer.scanForPaths(instance);

    // æ³¨å†Œåˆ° HTTP é€‚é…å™¨
    this.applyPathsToRouterProxy(
      httpAdapterRef,
      routerPaths,
      instanceWrapper,
      moduleKey,
      routePathMetadata,
      host,
    );
  }

  // æ³¨å†Œè·¯ç”±
  public applyPathsToRouterProxy(
    router: HttpServer,
    routeDefinitions: RouteDefinition[],
    instanceWrapper: InstanceWrapper,
    moduleKey: string,
    routePathMetadata: RoutePathMetadata,
    host: string | RegExp | Array<string | RegExp>,
  ) {
    routeDefinitions.forEach(routeDefinition => {
      this.applyCallbackToRouter(
        router,
        routeDefinition,
        instanceWrapper,
        moduleKey,
        routePathMetadata,
        host,
      );
    });
  }

  // ç»‘å®šå¤„ç†å‡½æ•°
  private applyCallbackToRouter(
    router: HttpServer,
    routeDefinition: RouteDefinition,
    instanceWrapper: InstanceWrapper,
    moduleKey: string,
    routePathMetadata: RoutePathMetadata,
    host: string | RegExp | Array<string | RegExp>,
  ) {
    const { path, requestMethod, targetCallback, methodName } = routeDefinition;

    // åˆ›å»ºæ‰§è¡Œä¸Šä¸‹æ–‡
    const executionContext = this.executionContextCreator.create(
      instanceWrapper,
      targetCallback,
      methodName,
      moduleKey,
      requestMethod,
    );

    // åˆ›å»ºä»£ç†å¤„ç†å‡½æ•°
    const proxy = this.createCallbackProxy(
      instanceWrapper,
      executionContext,
      methodName,
      moduleKey,
      requestMethod,
    );

    // æ„å»ºå®Œæ•´è·¯å¾„
    const fullPath = this.routePathFactory.create(routePathMetadata, requestMethod);

    // æ³¨å†Œåˆ°è·¯ç”±å™¨
    this.routerMethodFactory
      .get(router, requestMethod)
      .call(router, fullPath, proxy);

    this.logger.log(ROUTE_MAPPED_MESSAGE(fullPath, requestMethod));
  }
}
```

## RouterExecutionContext

åˆ›å»ºè·¯ç”±æ‰§è¡Œä¸Šä¸‹æ–‡ï¼Œç»„è£…å®Œæ•´çš„è¯·æ±‚å¤„ç†ç®¡é“ï¼š

```typescript
// packages/core/router/router-execution-context.ts
export class RouterExecutionContext {
  public create(
    instance: Controller,
    callback: (...args: any[]) => unknown,
    methodName: string,
    moduleKey: string,
    requestMethod: RequestMethod,
    contextId = STATIC_CONTEXT,
    inquirerId?: string,
  ) {
    const contextType: ContextType = 'http';
    
    // è·å–å…ƒæ•°æ®
    const { argsLength, fnHandleResponse, paramtypes, getParamsMetadata, httpStatusCode, responseHeaders } = 
      this.getMetadata(instance, callback, methodName, moduleKey, requestMethod, contextType);

    // åˆ›å»ºç®¡é“
    const pipes = this.pipesContextCreator.create(instance, callback, moduleKey, contextId, inquirerId);
    
    // åˆ›å»ºå®ˆå«
    const guards = this.guardsContextCreator.create(instance, callback, moduleKey, contextId, inquirerId);
    
    // åˆ›å»ºæ‹¦æˆªå™¨
    const interceptors = this.interceptorsContextCreator.create(instance, callback, moduleKey, contextId, inquirerId);

    // åˆ›å»ºå®ˆå«æ‰§è¡Œå‡½æ•°
    const fnCanActivate = this.createGuardsFn(guards, instance, callback, contextType);
    
    // åˆ›å»ºç®¡é“æ‰§è¡Œå‡½æ•°
    const fnApplyPipes = this.createPipesFn(pipes, paramsOptions);

    // è¿”å›è¯·æ±‚å¤„ç†å‡½æ•°
    return async <TRequest, TResponse>(req: TRequest, res: TResponse, next: Function) => {
      const args = this.contextUtils.createNullArray(argsLength);
      
      // 1. æ‰§è¡Œå®ˆå«
      fnCanActivate && (await fnCanActivate([req, res, next]));

      // 2. è®¾ç½®å“åº”çŠ¶æ€å’Œå¤´
      this.responseController.setStatus(res, httpStatusCode);
      hasCustomHeaders && this.responseController.setHeaders(res, responseHeaders);

      // 3. æ‰§è¡Œæ‹¦æˆªå™¨ï¼ˆåŒ…å«ç®¡é“å’Œå¤„ç†å™¨ï¼‰
      const result = await this.interceptorsConsumer.intercept(
        interceptors,
        [req, res, next],
        instance,
        callback,
        handler(args, req, res, next),  // å†…éƒ¨æ‰§è¡Œç®¡é“å’Œå¤„ç†å™¨
        contextType,
      );
      
      // 4. å¤„ç†å“åº”
      await fnHandleResponse(result, res, req);
    };
  }
}
```

å…³é”®ç‚¹ï¼š
- æŒ‰é¡ºåºåˆ›å»º Guardsã€Interceptorsã€Pipes
- å®ˆå«åœ¨æ‹¦æˆªå™¨ä¹‹å‰æ‰§è¡Œ
- ç®¡é“åœ¨è·¯ç”±å¤„ç†å™¨ä¹‹å‰æ‰§è¡Œï¼ˆåœ¨æ‹¦æˆªå™¨å†…éƒ¨ï¼‰
```

## è¯·æ±‚å¤„ç†æµç¨‹

```
Request
   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. Guards (å®ˆå«)                    â”‚
â”‚    canActivate() â†’ true/false       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. Interceptors (æ‹¦æˆªå™¨ - before)   â”‚
â”‚    intercept() â†’ Observable         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. Pipes (ç®¡é“)                     â”‚
â”‚    transform() â†’ value              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. Route Handler (è·¯ç”±å¤„ç†å™¨)       â”‚
â”‚    controller.method()              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 5. Interceptors (æ‹¦æˆªå™¨ - after)    â”‚
â”‚    Observable.pipe()                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 6. Exception Filters (å¼‚å¸¸è¿‡æ»¤å™¨)   â”‚
â”‚    catch() â†’ response               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â†“
Response
```

## GuardsConsumer

æ‰§è¡Œå®ˆå«ï¼š

```typescript
// packages/core/guards/guards-consumer.ts
export class GuardsConsumer {
  public async tryActivate(
    guards: CanActivate[],
    args: unknown[],
    instance: Controller,
    callback: (...args: unknown[]) => unknown,
    type?: string,
  ): Promise<boolean> {
    if (!guards || isEmpty(guards)) {
      return true;
    }

    const context = this.createContext(args, instance, callback);
    context.setType(type);

    // ä¾æ¬¡æ‰§è¡Œå®ˆå«
    for (const guard of guards) {
      const result = guard.canActivate(context);

      // å¤„ç†åŒæ­¥/å¼‚æ­¥/Observable ç»“æœ
      if (typeof result === 'boolean') {
        if (!result) return false;
        continue;
      }

      if (await this.pickResult(result)) {
        continue;
      }
      return false;
    }
    return true;
  }
}
```

## InterceptorsConsumer

æ‰§è¡Œæ‹¦æˆªå™¨ï¼š

```typescript
// packages/core/interceptors/interceptors-consumer.ts
export class InterceptorsConsumer {
  public async intercept(
    interceptors: NestInterceptor[],
    args: unknown[],
    instance: Controller,
    callback: (...args: unknown[]) => unknown,
    next: () => Promise<unknown>,
    type?: string,
  ): Promise<unknown> {
    if (isEmpty(interceptors)) {
      return next();
    }

    const context = this.createContext(args, instance, callback);
    context.setType(type);

    // æ„å»ºæ‹¦æˆªå™¨é“¾
    const nextFn = async (i = 0) => {
      if (i >= interceptors.length) {
        return defer(() => this.transformDeferred(next));
      }

      const handler: CallHandler = {
        handle: () => defer(() => nextFn(i + 1)).pipe(mergeAll()),
      };

      return interceptors[i].intercept(context, handler);
    };

    return defer(() => nextFn()).pipe(mergeAll());
  }
}
```

## PipesConsumer

æ‰§è¡Œç®¡é“ï¼š

```typescript
// packages/core/pipes/pipes-consumer.ts
export class PipesConsumer {
  public async apply(
    value: unknown,
    { metatype, type, data }: ArgumentMetadata,
    pipes: PipeTransform[],
  ) {
    return this.applyPipes(value, { metatype, type, data }, pipes);
  }

  public async applyPipes(
    value: unknown,
    metadata: { metatype: any; type?: any; data?: any },
    transforms: PipeTransform[],
  ) {
    // ä¾æ¬¡æ‰§è¡Œç®¡é“
    return transforms.reduce(async (deferredValue, pipe) => {
      const val = await deferredValue;
      const result = pipe.transform(val, metadata);
      return result;
    }, Promise.resolve(value));
  }
}
```

## å‚æ•°è§£æ

### RouteParamsFactory

```typescript
// packages/core/router/route-params-factory.ts
export class RouteParamsFactory {
  public exchangeKeyForValue(
    key: RouteParamtypes,
    data: string | object | any,
    { req, res, next }: { req: any; res: any; next: Function },
  ) {
    switch (key) {
      case RouteParamtypes.REQUEST:
        return req;
      case RouteParamtypes.RESPONSE:
        return res;
      case RouteParamtypes.NEXT:
        return next;
      case RouteParamtypes.BODY:
        return data ? req.body?.[data] : req.body;
      case RouteParamtypes.PARAM:
        return data ? req.params?.[data] : req.params;
      case RouteParamtypes.QUERY:
        return data ? req.query?.[data] : req.query;
      case RouteParamtypes.HEADERS:
        return data ? req.headers?.[data.toLowerCase()] : req.headers;
      case RouteParamtypes.IP:
        return req.ip;
      case RouteParamtypes.HOST:
        return req.hostname;
      default:
        return null;
    }
  }
}
```

## å¼‚å¸¸å¤„ç†

### ExceptionsHandler

```typescript
// packages/core/exceptions/exceptions-handler.ts
export class ExceptionsHandler {
  public handle(
    exception: Error | HttpException | any,
    host: ArgumentsHost,
  ): void {
    // å°è¯•ä½¿ç”¨è‡ªå®šä¹‰è¿‡æ»¤å™¨
    for (const filter of this.filters) {
      if (this.isExceptionOfType(exception, filter.exceptionMetatypes)) {
        filter.func(exception, host);
        return;
      }
    }

    // ä½¿ç”¨é»˜è®¤å¤„ç†
    this.invokeCustomFilters(exception, host);
  }
}
```

## ç‰ˆæœ¬æ§åˆ¶

```typescript
@Controller({
  path: 'cats',
  version: '1',
})
export class CatsControllerV1 {}

@Controller({
  path: 'cats',
  version: '2',
})
export class CatsControllerV2 {}
```

ç‰ˆæœ¬è·¯ç”±å¤„ç†ï¼š

```typescript
// packages/core/router/router-explorer.ts
private applyVersionFilter(
  router: HttpServer,
  routePathMetadata: RoutePathMetadata,
  versioningOptions: VersioningOptions,
) {
  const version = routePathMetadata.methodVersion;

  if (versioningOptions.type === VersioningType.URI) {
    // URI ç‰ˆæœ¬ï¼š/v1/cats
    return this.routePathFactory.create(routePathMetadata, requestMethod);
  }

  if (versioningOptions.type === VersioningType.HEADER) {
    // Header ç‰ˆæœ¬ï¼šX-API-Version: 1
    return this.createVersionedHandler(version);
  }

  if (versioningOptions.type === VersioningType.MEDIA_TYPE) {
    // Media Type ç‰ˆæœ¬ï¼šAccept: application/json;v=1
    return this.createMediaTypeVersionedHandler(version);
  }
}
```

## æ€»ç»“

NestJS è·¯ç”±ç³»ç»Ÿçš„æ ¸å¿ƒï¼š

1. **RoutesResolver**ï¼šè§£ææ‰€æœ‰æ§åˆ¶å™¨çš„è·¯ç”±
2. **RouterExplorer**ï¼šæ¢ç´¢è·¯ç”±æ–¹æ³•ï¼Œæ³¨å†Œåˆ° HTTP é€‚é…å™¨
3. **RouterExecutionContext**ï¼šåˆ›å»ºæ‰§è¡Œä¸Šä¸‹æ–‡ï¼Œç»„è£…ç®¡é“
4. **è¯·æ±‚å¤„ç†ç®¡é“**ï¼šGuards â†’ Interceptors â†’ Pipes â†’ Handler â†’ Interceptors â†’ Filters
5. **å‚æ•°è§£æ**ï¼šRouteParamsFactory è§£æ @Bodyã€@Query ç­‰
6. **ç‰ˆæœ¬æ§åˆ¶**ï¼šæ”¯æŒ URIã€Headerã€Media Type ä¸‰ç§æ–¹å¼

ä¸‹ä¸€ç¯‡æˆ‘ä»¬å°†åˆ†æä¸­é—´ä»¶æœºåˆ¶çš„å®ç°ã€‚

---

> ğŸ“¦ æºç ä½ç½®ï¼š`packages/core/router/`
>
> ä¸‹ä¸€ç¯‡ï¼šNestJS ä¸­é—´ä»¶æœºåˆ¶
