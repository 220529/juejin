# NestJS æºç è§£æï¼šä¾èµ–æ³¨å…¥ç³»ç»Ÿ

> æ·±å…¥ Injector å’Œ Containerï¼Œæ­ç§˜ NestJS çš„ IoC å®ç°ã€‚

## ä¾èµ–æ³¨å…¥åŸºç¡€

NestJS çš„ä¾èµ–æ³¨å…¥åŸºäº TypeScript è£…é¥°å™¨å’Œ `reflect-metadata`ï¼š

```typescript
@Injectable()
export class CatsService {
  constructor(private readonly logger: LoggerService) {}
}
```

ç¼–è¯‘åï¼ŒTypeScript ä¼šç”Ÿæˆå…ƒæ•°æ®ï¼Œè®°å½•æ„é€ å‡½æ•°å‚æ•°ç±»å‹ã€‚

## æ ¸å¿ƒç»„ä»¶

### 1. InstanceWrapper

åŒ…è£…æ¯ä¸ªå¯æ³¨å…¥çš„å®ä¾‹ï¼š

```typescript
// packages/core/injector/instance-wrapper.ts
export class InstanceWrapper<T = any> {
  public readonly name: string;
  public readonly token: InjectionToken;
  public readonly metatype: Type<T>;
  public readonly scope?: Scope;

  private readonly values = new WeakMap<ContextId, InstancePerContext<T>>();

  // è·å–å®ä¾‹
  get instance(): T {
    const instancePerContext = this.getInstanceByContextId(STATIC_CONTEXT);
    return instancePerContext.instance;
  }

  // è®¾ç½®å®ä¾‹
  set instance(value: T) {
    const instancePerContext = this.getInstanceByContextId(STATIC_CONTEXT);
    instancePerContext.instance = value;
  }

  // è·å–æ„é€ å‡½æ•°å…ƒæ•°æ®
  public getCtorMetadata(): InstanceWrapper[] {
    return this.inject || [];
  }
}
```

### 2. Module

æ¨¡å—ç±»ï¼Œç®¡ç† providersã€controllersã€importsã€exportsï¼š

```typescript
// packages/core/injector/module.ts
export class Module {
  private readonly _providers = new Map<InjectionToken, InstanceWrapper<Injectable>>();
  private readonly _controllers = new Map<InjectionToken, InstanceWrapper<Controller>>();
  private readonly _imports = new Set<Module>();
  private readonly _exports = new Set<InjectionToken>();

  // æ·»åŠ  Provider
  public addProvider(provider: Provider): string {
    if (this.isCustomProvider(provider)) {
      return this.addCustomProvider(provider);
    }

    const token = provider as Type<Injectable>;
    const wrapper = new InstanceWrapper({
      token,
      name: token.name,
      metatype: token,
      instance: null,
      isResolved: false,
      scope: getClassScope(token),
      host: this,
    });

    this._providers.set(token, wrapper);
    return token.name;
  }

  // æ·»åŠ è‡ªå®šä¹‰ Provider
  private addCustomProvider(provider: Provider): string {
    if (this.isCustomClass(provider)) {
      return this.addCustomClass(provider as ClassProvider);
    }
    if (this.isCustomValue(provider)) {
      return this.addCustomValue(provider as ValueProvider);
    }
    if (this.isCustomFactory(provider)) {
      return this.addCustomFactory(provider as FactoryProvider);
    }
    if (this.isCustomUseExisting(provider)) {
      return this.addCustomUseExisting(provider as ExistingProvider);
    }
  }
}
```

### 3. Injector

ä¾èµ–æ³¨å…¥æ ¸å¿ƒå¼•æ“ï¼š

```typescript
// packages/core/injector/injector.ts
export class Injector {
  // åŠ è½½å®ä¾‹
  public async loadInstance<T>(
    wrapper: InstanceWrapper<T>,
    collection: Map<InjectionToken, InstanceWrapper>,
    moduleRef: Module,
    contextId = STATIC_CONTEXT,
    inquirer?: InstanceWrapper,
  ) {
    const { token } = wrapper;

    // æ£€æŸ¥æ˜¯å¦å·²è§£æ
    const instanceHost = wrapper.getInstanceByContextId(contextId, inquirer?.id);
    if (instanceHost.isResolved) {
      return instanceHost.instance;
    }

    // è§£ææ„é€ å‡½æ•°ä¾èµ–
    const dependencies = await this.resolveConstructorParams<T>(
      wrapper,
      moduleRef,
      contextId,
      inquirer,
    );

    // å®ä¾‹åŒ–
    const instance = await this.instantiateClass(
      dependencies,
      wrapper,
      wrapper.inject,
      contextId,
      inquirer,
    );

    // æ³¨å…¥å±æ€§ä¾èµ–
    await this.loadPropertiesOnInstance(instance, wrapper, moduleRef, contextId);

    return instance;
  }

  // è§£ææ„é€ å‡½æ•°å‚æ•°
  public async resolveConstructorParams<T>(
    wrapper: InstanceWrapper<T>,
    moduleRef: Module,
    contextId: ContextId,
    inquirer?: InstanceWrapper,
  ): Promise<unknown[]> {
    // è·å–ä¾èµ–å…ƒæ•°æ®
    const dependencies = this.getCtorDependencies(wrapper);

    // å¹¶è¡Œè§£ææ‰€æœ‰ä¾èµ–
    return Promise.all(
      dependencies.map(async (dependency, index) => {
        const { wrapper: instanceWrapper } = await this.lookupComponent(
          dependency,
          moduleRef,
          contextId,
          wrapper,
          index,
        );
        return instanceWrapper.instance;
      }),
    );
  }

  // æŸ¥æ‰¾ä¾èµ–
  public async lookupComponent(
    dependency: InjectorDependency,
    moduleRef: Module,
    contextId: ContextId,
    wrapper: InstanceWrapper,
    index: number,
  ) {
    // 1. åœ¨å½“å‰æ¨¡å—æŸ¥æ‰¾
    const instanceWrapper = await this.lookupComponentInParentModules(
      dependency,
      moduleRef,
      contextId,
      wrapper,
      index,
    );

    if (instanceWrapper) {
      return { wrapper: instanceWrapper };
    }

    // 2. åœ¨å…¨å±€æ¨¡å—æŸ¥æ‰¾
    const globalWrapper = await this.lookupComponentInGlobalModules(
      dependency,
      contextId,
      wrapper,
    );

    if (globalWrapper) {
      return { wrapper: globalWrapper };
    }

    // 3. æœªæ‰¾åˆ°ï¼ŒæŠ›å‡ºå¼‚å¸¸
    throw new UndefinedDependencyException(wrapper.name, dependency, index);
  }
}
```

## ä¾èµ–è§£ææµç¨‹

```
@Injectable()
class CatsService {
  constructor(
    private logger: LoggerService,
    private config: ConfigService,
  ) {}
}

è§£ææµç¨‹ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. è·å–æ„é€ å‡½æ•°å‚æ•°ç±»å‹                              â”‚
â”‚    Reflect.getMetadata('design:paramtypes', target) â”‚
â”‚    â†’ [LoggerService, ConfigService]                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. éå†æ¯ä¸ªä¾èµ–ï¼Œè°ƒç”¨ lookupComponent               â”‚
â”‚    â†’ åœ¨å½“å‰æ¨¡å— providers ä¸­æŸ¥æ‰¾                    â”‚
â”‚    â†’ åœ¨ imports çš„æ¨¡å— exports ä¸­æŸ¥æ‰¾               â”‚
â”‚    â†’ åœ¨å…¨å±€æ¨¡å—ä¸­æŸ¥æ‰¾                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. é€’å½’è§£æä¾èµ–çš„ä¾èµ–                               â”‚
â”‚    LoggerService å¯èƒ½ä¹Ÿæœ‰è‡ªå·±çš„ä¾èµ–                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. å®ä¾‹åŒ–                                           â”‚
â”‚    new CatsService(loggerInstance, configInstance)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ä½œç”¨åŸŸ

NestJS æ”¯æŒä¸‰ç§ä½œç”¨åŸŸï¼š

```typescript
export enum Scope {
  DEFAULT = 0,    // å•ä¾‹
  TRANSIENT = 1,  // æ¯æ¬¡æ³¨å…¥åˆ›å»ºæ–°å®ä¾‹
  REQUEST = 2,    // æ¯ä¸ªè¯·æ±‚åˆ›å»ºæ–°å®ä¾‹
}
```

### å•ä¾‹ (DEFAULT)

```typescript
@Injectable()
export class CatsService {}
```

æ•´ä¸ªåº”ç”¨ç”Ÿå‘½å‘¨æœŸåªæœ‰ä¸€ä¸ªå®ä¾‹ã€‚

### ç¬æ€ (TRANSIENT)

```typescript
@Injectable({ scope: Scope.TRANSIENT })
export class LoggerService {}
```

æ¯æ¬¡æ³¨å…¥éƒ½åˆ›å»ºæ–°å®ä¾‹ï¼š

```typescript
// packages/core/injector/injector.ts
if (wrapper.scope === Scope.TRANSIENT) {
  return this.instantiateClass(
    dependencies,
    wrapper,
    wrapper.inject,
    contextId,
    inquirer,
  );
}
```

### è¯·æ±‚ä½œç”¨åŸŸ (REQUEST)

```typescript
@Injectable({ scope: Scope.REQUEST })
export class RequestService {}
```

æ¯ä¸ª HTTP è¯·æ±‚åˆ›å»ºæ–°å®ä¾‹ï¼š

```typescript
// packages/core/router/router-execution-context.ts
if (wrapper.scope === Scope.REQUEST) {
  const contextId = createContextId();
  const instance = await this.injector.loadInstance(
    wrapper,
    collection,
    moduleRef,
    contextId,
  );
  return instance;
}
```

## è‡ªå®šä¹‰ Provider

### useClass

```typescript
{
  provide: CatsService,
  useClass: MockCatsService,
}
```

### useValue

```typescript
{
  provide: 'CONFIG',
  useValue: { apiKey: 'xxx' },
}
```

### useFactory

```typescript
{
  provide: 'ASYNC_CONNECTION',
  useFactory: async (config: ConfigService) => {
    return await createConnection(config.get('database'));
  },
  inject: [ConfigService],
}
```

### useExisting

```typescript
{
  provide: 'AliasService',
  useExisting: CatsService,
}
```

## å¾ªç¯ä¾èµ–å¤„ç†

NestJS ä½¿ç”¨ `forwardRef` å¤„ç†å¾ªç¯ä¾èµ–ï¼š

```typescript
@Injectable()
export class CatsService {
  constructor(
    @Inject(forwardRef(() => DogsService))
    private dogsService: DogsService,
  ) {}
}
```

å®ç°åŸç†ï¼š

```typescript
// packages/common/utils/forward-ref.util.ts
export const forwardRef = (fn: () => any): ForwardReference => ({
  forwardRef: fn,
});

// packages/core/injector/injector.ts
private resolveParamToken(param: any) {
  if (param && param.forwardRef) {
    return param.forwardRef();
  }
  return param;
}
```

## å±æ€§æ³¨å…¥

é™¤äº†æ„é€ å‡½æ•°æ³¨å…¥ï¼Œè¿˜æ”¯æŒå±æ€§æ³¨å…¥ï¼š

```typescript
@Injectable()
export class CatsService {
  @Inject(LoggerService)
  private readonly logger: LoggerService;
}
```

å®ç°ï¼š

```typescript
// packages/core/injector/injector.ts
public async loadPropertiesOnInstance(
  instance: object,
  wrapper: InstanceWrapper,
  moduleRef: Module,
  contextId: ContextId,
) {
  const properties = wrapper.getPropertiesMetadata();

  for (const property of properties) {
    const { key, wrapper: propertyWrapper } = await this.lookupComponent(
      property.name,
      moduleRef,
      contextId,
      wrapper,
    );
    instance[key] = propertyWrapper.instance;
  }
}
```

## æ€»ç»“

NestJS ä¾èµ–æ³¨å…¥ç³»ç»Ÿçš„æ ¸å¿ƒï¼š

1. **å…ƒæ•°æ®é©±åŠ¨**ï¼šé€šè¿‡ `reflect-metadata` è·å–ç±»å‹ä¿¡æ¯
2. **InstanceWrapper**ï¼šåŒ…è£…æ¯ä¸ªå¯æ³¨å…¥å®ä¾‹
3. **Module**ï¼šç®¡ç† providersã€controllersã€importsã€exports
4. **Injector**ï¼šé€’å½’è§£æä¾èµ–ï¼Œå®ä¾‹åŒ–å¯¹è±¡
5. **ä½œç”¨åŸŸ**ï¼šæ”¯æŒå•ä¾‹ã€ç¬æ€ã€è¯·æ±‚ä¸‰ç§ä½œç”¨åŸŸ
6. **å¾ªç¯ä¾èµ–**ï¼šé€šè¿‡ `forwardRef` å»¶è¿Ÿè§£æ

ä¸‹ä¸€ç¯‡æˆ‘ä»¬å°†åˆ†ææ¨¡å—ç³»ç»Ÿçš„å®ç°ã€‚

---

> ğŸ“¦ æºç ä½ç½®ï¼š`packages/core/injector/`
>
> ä¸‹ä¸€ç¯‡ï¼šNestJS æ¨¡å—ç³»ç»Ÿ
