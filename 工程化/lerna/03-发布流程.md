# Lerna 源码解析：发布流程

> 本文深入分析 lerna publish 命令的实现，理解多包发布到 npm 的完整流程。

## publish 命令概览

```
┌─────────────────────────────────────────────────────────────────┐
│                    lerna publish 流程                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   1. 确定要发布的包                                              │
│      │  - from-git: 从 git tag 获取                             │
│      │  - from-package: 从 package.json 获取                    │
│      │  - 默认: 先执行 version                                   │
│      ▼                                                           │
│   2. 准备发布                                                    │
│      │  - 验证 npm 权限                                          │
│      │  - 处理 License                                           │
│      │  - 处理私有包                                             │
│      ▼                                                           │
│   3. 解析依赖链接                                                │
│      │  - file: 链接转版本号                                     │
│      │  - workspace: 链接转版本号                                │
│      ▼                                                           │
│   4. 打包                                                        │
│      │  - npm pack                                               │
│      ▼                                                           │
│   5. 发布                                                        │
│      │  - npm publish                                            │
│      │  - 处理 2FA                                               │
│      ▼                                                           │
│   6. 清理                                                        │
│      │  - 恢复 private 字段                                      │
│      │  - git reset                                              │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## PublishCommand 实现

```typescript
// libs/commands/publish/src/index.ts
class PublishCommand extends Command {
  packagesToPublish?: Package[];
  publishedPackages?: Package[];

  async initialize() {
    // 1. 确定发布模式
    let result;
    if (this.options.bump === "from-git") {
      result = await this.detectFromGit();
    } else if (this.options.bump === "from-package") {
      result = await this.detectFromPackage();
    } else if (this.options.canary) {
      result = await this.detectCanaryVersions();
    } else {
      // 默认：先执行 version 命令
      result = await versionCommand(this.argv);
    }

    if (!result || !result.updates.length) {
      this.logger.success("", "No changed packages to publish");
      return false;
    }

    this.updates = result.updates;
    this.updatesVersions = new Map(result.updatesVersions);
    this.packagesToPublish = this.updates.map((node) => getPackage(node));

    // 2. 确认发布
    if (result.needsConfirmation && !this.options.yes) {
      return this.confirmPublish();
    }

    return true;
  }

  async execute() {
    this.logger.info("publish", "Publishing packages to npm...");

    // 1. 准备发布
    await this.prepareRegistryActions();
    await this.prepareLicenseActions();
    this.preparePrivatePackages();

    // 2. Canary 版本更新
    if (this.options.canary) {
      await this.updateCanaryVersions();
    }

    // 3. 解析依赖链接
    await this.resolveLocalDependencyLinks();
    await this.resolveWorkspaceDependencyLinks();

    // 4. 注入 gitHead
    this.annotateGitHead();

    // 5. 序列化更改
    await this.serializeChanges();

    // 6. 打包
    await this.packUpdated();

    // 7. 发布
    await this.publishPacked();

    // 8. 恢复私有包
    this.restorePrivatePackages();
    await this.serializeChanges();

    // 9. Git 重置
    if (this.gitReset) {
      await this.resetChanges();
    }

    // 10. 更新 dist-tag
    if (this.options.tempTag) {
      await this.npmUpdateAsLatest();
    }

    // 11. 输出结果
    this.logPublishedPackages();
  }
}
```

## 发布模式

### from-git

从 git tag 获取要发布的包：

```typescript
async detectFromGit() {
  // 检查工作区是否干净
  await this.verifyWorkingTreeClean();

  // 获取当前 tag
  const matchingPattern = this.project.isIndependent() 
    ? "*@*" 
    : `${this.tagPrefix}*.*.*`;
  
  const taggedPackageNames = await getCurrentTags(this.execOpts, matchingPattern);

  if (!taggedPackageNames.length) {
    this.logger.notice("from-git", "No tagged release found");
    return { updates: [], needsConfirmation: false };
  }

  // 解析 tag 获取包和版本
  let updates, updatesVersions;
  
  if (this.project.isIndependent()) {
    updates = [];
    updatesVersions = [];
    
    taggedPackageNames.forEach((tag) => {
      const npaResult = npa(tag);  // package-a@1.0.0
      const node = this.projectsWithPackage.find(
        (n) => getPackage(n).name === npaResult.name
      );
      updates.push(node);
      updatesVersions.push([node.name, npaResult.rawSpec]);
    });
  } else {
    updates = await getProjectsWithTaggedPackages(
      this.projectsWithPackage,
      this.projectFileMap,
      this.execOpts
    );
    updatesVersions = updates.map((node) => [node.name, getPackage(node).version]);
  }

  return { updates, updatesVersions, needsConfirmation: true };
}
```

### from-package

从 package.json 获取未发布的包：

```typescript
async detectFromPackage() {
  await this.verifyWorkingTreeClean();

  // 获取未发布的包
  const updates = await getProjectsWithUnpublishedPackages(
    this.projectsWithPackage,
    this.conf.snapshot
  );

  if (!updates.length) {
    this.logger.notice("from-package", "No unpublished release found");
  }

  const updatesVersions = updates.map((node) => [
    node.name, 
    getPackage(node).version
  ]);

  return { updates, updatesVersions, needsConfirmation: true };
}

// 检查包是否已发布
async function getProjectsWithUnpublishedPackages(
  projects: ProjectGraphProjectNodeWithPackage[],
  npmConfig: NpmConfig
): Promise<ProjectGraphProjectNodeWithPackage[]> {
  const unpublished = [];

  for (const node of projects) {
    const pkg = getPackage(node);
    
    // 查询 npm registry
    const published = await isPackagePublished(pkg.name, pkg.version, npmConfig);
    
    if (!published) {
      unpublished.push(node);
    }
  }

  return unpublished;
}
```

### Canary 发布

```typescript
async detectCanaryVersions() {
  const { bump = "prepatch", preid = "alpha" } = this.options;
  
  await this.verifyWorkingTreeClean();

  // 检测变更的包
  const updates = collectProjectUpdates(
    this.projectsWithPackage,
    this.projectGraph,
    this.execOpts,
    { bump: "prerelease", canary: true, ...this.options }
  );

  // 生成 canary 版本号
  const makeVersion = ({ lastVersion, refCount, sha }) => {
    const nextVersion = semver.inc(lastVersion, bump.replace("pre", ""));
    // 1.0.1-alpha.0+abc1234
    return `${nextVersion}-${preid}.${Math.max(0, refCount - 1)}+${sha}`;
  };

  let updatesVersions;
  if (this.project.isIndependent()) {
    updatesVersions = await pMap(updates, async (node) => {
      const ref = await describeRef({ match: `${getPackage(node).name}@*` });
      return [node.name, makeVersion(ref)];
    });
  } else {
    const ref = await describeRef({ match: `${this.tagPrefix}*.*.*` });
    const version = makeVersion(ref);
    updatesVersions = updates.map((node) => [node.name, version]);
  }

  return { updates, updatesVersions, needsConfirmation: true };
}
```

## 依赖链接解析

```typescript
// 解析 file: 链接
async resolveLocalDependencyLinks() {
  const updatesWithLocalLinks = this.updates.filter((node) => {
    const deps = this.projectGraph.localPackageDependencies[node.name] || [];
    return deps.some((dep) => dep.targetResolvedNpaResult.type === "directory");
  });

  await pMap(updatesWithLocalLinks, (node) => {
    const pkg = getPackage(node);
    const deps = this.projectGraph.localPackageDependencies[node.name] || [];

    deps.forEach((dep) => {
      const depPkg = getPackage(this.projectGraph.nodes[dep.target]);
      const depVersion = this.updatesVersions.get(dep.target) || depPkg.version;

      // file:../sibling-pkg -> ^1.0.0
      pkg.updateLocalDependency(dep.targetResolvedNpaResult, depVersion, this.savePrefix);
    });
  });
}

// 解析 workspace: 链接
async resolveWorkspaceDependencyLinks() {
  const updatesWithWorkspaceLinks = this.updates.filter((node) => {
    const deps = this.projectGraph.localPackageDependencies[node.name] || [];
    return deps.some((dep) => !!dep.targetResolvedNpaResult.workspaceSpec);
  });

  await pMap(updatesWithWorkspaceLinks, (node) => {
    const pkg = getPackage(node);
    const deps = this.projectGraph.localPackageDependencies[node.name] || [];

    deps.forEach((dep) => {
      const resolved = dep.targetResolvedNpaResult;
      
      if (resolved.workspaceSpec) {
        const depPkg = getPackage(this.projectGraph.nodes[dep.target]);
        const depVersion = this.updatesVersions.get(dep.target) || depPkg.version;

        // workspace:^ -> ^1.0.0
        // workspace:* -> 1.0.0
        let savePrefix = "";
        if (resolved.workspaceAlias === "^") savePrefix = "^";
        if (resolved.workspaceAlias === "~") savePrefix = "~";

        pkg.updateLocalDependency(resolved, depVersion, savePrefix, {
          eraseWorkspacePrefix: true,
        });
      }
    });
  });
}
```

## 打包和发布

### 打包

```typescript
// libs/core/src/lib/pack-directory.ts
async packUpdated() {
  await this.topoMapPackages(async (pkg) => {
    // 执行 prepublish 脚本
    if (!this.options.ignorePrepublish) {
      await this.runPackageLifecycle(pkg, "prepublish");
    }

    // 执行 prepare 脚本
    await this.runPackageLifecycle(pkg, "prepare");

    // 执行 prepublishOnly 脚本
    await this.runPackageLifecycle(pkg, "prepublishOnly");

    // 执行 prepack 脚本
    await this.runPackageLifecycle(pkg, "prepack");

    // npm pack
    const packed = await packDirectory(pkg, pkg.contents, this.conf.snapshot);

    // 执行 postpack 脚本
    await this.runPackageLifecycle(pkg, "postpack");

    // 记录打包信息
    logPacked(pkg, packed);

    return packed;
  });
}

export async function packDirectory(
  pkg: Package,
  directory: string,
  options: NpmConfig
): Promise<Packed> {
  // 使用 npm-packlist 获取要打包的文件
  const files = await packlist({ path: directory });

  // 创建 tarball
  const tarball = await tar.create(
    {
      cwd: directory,
      prefix: "package/",
      portable: true,
      gzip: true,
    },
    files
  );

  // 计算完整性哈希
  const integrity = ssri.fromData(tarball);

  return {
    filename: `${pkg.name}-${pkg.version}.tgz`,
    files,
    tarball,
    integrity: integrity.toString(),
  };
}
```

### 发布

```typescript
// libs/core/src/lib/npm-publish.ts
async publishPacked() {
  const mapper = this.options.throttle
    ? this.throttledPublish.bind(this)
    : this.publish.bind(this);

  this.publishedPackages = [];

  await this.topoMapPackages(async (pkg) => {
    const result = await mapper(pkg);
    if (result) {
      this.publishedPackages.push(pkg);
    }
  });
}

async publish(pkg: Package): Promise<boolean> {
  const { registry, tag } = this.conf.snapshot;

  try {
    // 执行 publish 脚本
    await this.runPackageLifecycle(pkg, "publish");

    // npm publish
    await npmPublish(pkg, pkg.packed.tarball, {
      ...this.conf.snapshot,
      tag: this.options.tempTag || tag,
    });

    // 执行 postpublish 脚本
    await this.runPackageLifecycle(pkg, "postpublish");

    this.logger.success("published", `${pkg.name}@${pkg.version}`);
    return true;
  } catch (err) {
    this.logger.error("publish", `Failed to publish ${pkg.name}@${pkg.version}`);
    throw err;
  }
}

export async function npmPublish(
  pkg: Package,
  tarball: Buffer,
  options: NpmConfig
): Promise<void> {
  const { registry, tag, token, otp } = options;

  await libnpmpublish.publish(
    pkg.toJSON(),
    tarball,
    {
      registry,
      tag,
      token,
      otp,
      access: pkg.get("publishConfig")?.access || "public",
    }
  );
}
```

## 2FA 处理

```typescript
// libs/core/src/lib/otplease.ts
async requestOneTimePassword() {
  if (this.otpCache.otp) {
    return;
  }

  const otp = await getOneTimePassword("Enter OTP:");
  this.otpCache.otp = otp;
}

export async function otplease<T>(
  fn: (opts: { otp?: string }) => Promise<T>,
  opts: { otp?: string },
  otpCache: { otp?: string }
): Promise<T> {
  try {
    return await fn(opts);
  } catch (err) {
    if (isOTPError(err)) {
      // 需要 OTP
      const otp = await getOneTimePassword("This operation requires a one-time password:");
      otpCache.otp = otp;
      
      return fn({ ...opts, otp });
    }
    throw err;
  }
}

function isOTPError(err: Error): boolean {
  return (
    err.code === "EOTP" ||
    err.code === "E401" ||
    /one-time pass/i.test(err.message)
  );
}
```

## 发布节流

```typescript
// 防止并发发布过多导致 npm 限流
async throttledPublish(pkg: Package): Promise<boolean> {
  const { throttleSize = 10, throttleDelay = 1000 } = this.options;

  // 使用队列控制并发
  return this.publishQueue.add(async () => {
    const result = await this.publish(pkg);
    
    // 发布后延迟
    await new Promise((resolve) => setTimeout(resolve, throttleDelay));
    
    return result;
  });
}
```

## 发布后清理

```typescript
// 恢复私有包的 private 字段
restorePrivatePackages() {
  this.privatePackagesToPublish.forEach((pkg) => {
    pkg.private = true;
  });
}

// Git 重置
async resetChanges() {
  const dirtyManifests = [this.project.manifest]
    .concat(this.packagesToPublish)
    .map((pkg) => path.relative(workspaceRoot, pkg.manifestLocation));

  try {
    await gitCheckout(dirtyManifests, this.execOpts);
  } catch (err) {
    this.logger.notice("FYI", "Unable to reset working tree changes");
  }
}
```

## 小结

lerna publish 的核心流程：

1. **发布模式**：from-git、from-package、canary、默认（先 version）
2. **依赖解析**：file: 和 workspace: 链接转换为版本号
3. **打包**：执行生命周期脚本，npm pack
4. **发布**：npm publish，支持 2FA 和节流
5. **清理**：恢复私有字段，git reset

---

> 下一篇：变更检测
