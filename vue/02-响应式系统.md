# Vue.js æºç æ­ç§˜ï¼ˆäºŒï¼‰ï¼šå“åº”å¼ç³»ç»Ÿ

> æœ¬æ–‡æ·±å…¥ reactivity åŒ…æºç ï¼Œè§£æ reactiveã€refã€effect çš„å®ç°åŸç†ã€‚

## ä¸€ã€å“åº”å¼æ¦‚è§ˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    å“åº”å¼ç³»ç»Ÿ                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚   reactive(obj)  â”€â”€â–º Proxy â”€â”€â–º get: track / set: trigger   â”‚
â”‚                                                             â”‚
â”‚   ref(value)     â”€â”€â–º RefImpl â”€â”€â–º get: track / set: trigger â”‚
â”‚                                                             â”‚
â”‚   effect(fn)     â”€â”€â–º ReactiveEffect â”€â”€â–º è‡ªåŠ¨æ”¶é›†ä¾èµ–        â”‚
â”‚                                                             â”‚
â”‚   computed(fn)   â”€â”€â–º ComputedRefImpl â”€â”€â–º æƒ°æ€§æ±‚å€¼ + ç¼“å­˜    â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## äºŒã€reactive å®ç°

### 2.1 createReactiveObject

```typescript
// packages/reactivity/src/reactive.ts
export function reactive(target) {
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  )
}

function createReactiveObject(
  target,
  isReadonly,
  baseHandlers,
  collectionHandlers,
  proxyMap
) {
  // éå¯¹è±¡ç›´æ¥è¿”å›
  if (!isObject(target)) {
    return target
  }
  
  // å·²ç»æ˜¯ Proxyï¼Œç›´æ¥è¿”å›
  if (target[ReactiveFlags.RAW]) {
    return target
  }
  
  // å·²æœ‰ç¼“å­˜ï¼Œè¿”å›ç¼“å­˜
  const existingProxy = proxyMap.get(target)
  if (existingProxy) {
    return existingProxy
  }
  
  // è·å–ç›®æ ‡ç±»å‹
  const targetType = getTargetType(target)
  if (targetType === TargetType.INVALID) {
    return target
  }
  
  // åˆ›å»º Proxy
  const proxy = new Proxy(
    target,
    targetType === TargetType.COLLECTION 
      ? collectionHandlers  // Map/Set
      : baseHandlers        // Object/Array
  )
  
  // ç¼“å­˜
  proxyMap.set(target, proxy)
  return proxy
}
```

### 2.2 baseHandlers

```typescript
// packages/reactivity/src/baseHandlers.ts
export const mutableHandlers: ProxyHandler<object> = {
  get(target, key, receiver) {
    // ç‰¹æ®Š key å¤„ç†
    if (key === ReactiveFlags.IS_REACTIVE) return true
    if (key === ReactiveFlags.RAW) return target
    
    const res = Reflect.get(target, key, receiver)
    
    // ä¾èµ–æ”¶é›†
    track(target, TrackOpTypes.GET, key)
    
    // æ·±å±‚å“åº”å¼
    if (isObject(res)) {
      return reactive(res)
    }
    
    return res
  },
  
  set(target, key, value, receiver) {
    const oldValue = target[key]
    const result = Reflect.set(target, key, value, receiver)
    
    // è§¦å‘æ›´æ–°
    if (hasChanged(value, oldValue)) {
      trigger(target, TriggerOpTypes.SET, key, value, oldValue)
    }
    
    return result
  },
  
  deleteProperty(target, key) {
    const hadKey = hasOwn(target, key)
    const result = Reflect.deleteProperty(target, key)
    
    if (result && hadKey) {
      trigger(target, TriggerOpTypes.DELETE, key)
    }
    
    return result
  }
}
```

## ä¸‰ã€Dep ä¾èµ–å®¹å™¨

```typescript
// packages/reactivity/src/dep.ts
export class Dep {
  version = 0
  activeLink?: Link
  subs?: Link        // è®¢é˜…è€…é“¾è¡¨å°¾
  subsHead?: Link    // è®¢é˜…è€…é“¾è¡¨å¤´
  map?: KeyToDepMap
  key?: unknown
  sc: number = 0     // è®¢é˜…è€…è®¡æ•°
  
  constructor(public computed?: ComputedRefImpl) {}
  
  track() {
    if (!activeSub || !shouldTrack) return
    
    let link = this.activeLink
    if (!link || link.sub !== activeSub) {
      // åˆ›å»ºæ–°çš„ Link
      link = {
        dep: this,
        sub: activeSub,
        version: this.version,
        nextDep: undefined,
        prevDep: activeSub.depsTail,
        nextSub: undefined,
        prevSub: this.subs,
        prevActiveLink: this.activeLink
      }
      
      // æ·»åŠ åˆ°è®¢é˜…è€…çš„ä¾èµ–é“¾è¡¨
      if (activeSub.depsTail) {
        activeSub.depsTail.nextDep = link
      } else {
        activeSub.deps = link
      }
      activeSub.depsTail = link
      
      // æ·»åŠ åˆ° Dep çš„è®¢é˜…è€…é“¾è¡¨
      if (this.subs) {
        this.subs.nextSub = link
      }
      this.subs = link
      this.sc++
    }
    
    link.version = this.version
    this.activeLink = link
  }
  
  trigger() {
    this.version++
    
    // é€šçŸ¥æ‰€æœ‰è®¢é˜…è€…
    for (let link = this.subs; link; link = link.prevSub) {
      link.sub.notify()
    }
  }
}
```

## å››ã€ReactiveEffect

```typescript
// packages/reactivity/src/effect.ts
export let activeSub: Subscriber | undefined

export class ReactiveEffect {
  deps?: Link
  depsTail?: Link
  flags: EffectFlags = EffectFlags.ACTIVE | EffectFlags.TRACKING
  
  constructor(public fn: () => any) {
    // æ³¨å†Œåˆ° effectScope
    if (activeEffectScope?.active) {
      activeEffectScope.effects.push(this)
    }
  }
  
  run() {
    if (!(this.flags & EffectFlags.ACTIVE)) {
      return this.fn()
    }
    
    this.flags |= EffectFlags.RUNNING
    cleanupEffect(this)
    prepareDeps(this)
    
    const prevEffect = activeSub
    const prevShouldTrack = shouldTrack
    activeSub = this
    shouldTrack = true
    
    try {
      return this.fn()
    } finally {
      cleanupDeps(this)
      activeSub = prevEffect
      shouldTrack = prevShouldTrack
      this.flags &= ~EffectFlags.RUNNING
    }
  }
  
  notify() {
    if (this.flags & EffectFlags.RUNNING) return
    if (!(this.flags & EffectFlags.NOTIFIED)) {
      batch(this)
    }
  }
  
  stop() {
    if (this.flags & EffectFlags.ACTIVE) {
      for (let link = this.deps; link; link = link.nextDep) {
        removeSub(link)
      }
      this.deps = this.depsTail = undefined
      cleanupEffect(this)
      this.flags &= ~EffectFlags.ACTIVE
    }
  }
}
```

### 4.1 effect å‡½æ•°

```typescript
export function effect(fn, options?) {
  const e = new ReactiveEffect(fn)
  
  if (options) {
    extend(e, options)
  }
  
  e.run()
  
  const runner = e.run.bind(e)
  runner.effect = e
  return runner
}
```

## äº”ã€ref å®ç°

```typescript
// packages/reactivity/src/ref.ts
class RefImpl {
  _value: any
  _rawValue: any
  dep: Dep = new Dep()
  
  readonly [ReactiveFlags.IS_REF] = true
  
  constructor(value, isShallow) {
    this._rawValue = isShallow ? value : toRaw(value)
    this._value = isShallow ? value : toReactive(value)
  }
  
  get value() {
    this.dep.track()
    return this._value
  }
  
  set value(newValue) {
    const oldValue = this._rawValue
    const useDirectValue = this[ReactiveFlags.IS_SHALLOW] || 
                           isShallow(newValue) || 
                           isReadonly(newValue)
    
    newValue = useDirectValue ? newValue : toRaw(newValue)
    
    if (hasChanged(newValue, oldValue)) {
      this._rawValue = newValue
      this._value = useDirectValue ? newValue : toReactive(newValue)
      this.dep.trigger()
    }
  }
}

export function ref(value) {
  return createRef(value, false)
}

function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue
  }
  return new RefImpl(rawValue, shallow)
}
```

## å…­ã€computed å®ç°

```typescript
// packages/reactivity/src/computed.ts
class ComputedRefImpl {
  _value: any
  dep: Dep
  effect: ReactiveEffect
  
  readonly [ReactiveFlags.IS_REF] = true
  readonly [ReactiveFlags.IS_READONLY]: boolean
  
  constructor(getter, setter, isReadonly) {
    this.dep = new Dep(this)
    this[ReactiveFlags.IS_READONLY] = isReadonly
    
    this.effect = new ReactiveEffect(() => getter(this._value))
    this.effect.computed = this
    this.effect.scheduler = () => {
      // ä¾èµ–å˜åŒ–æ—¶ï¼Œæ ‡è®°ä¸ºè„
      if (!(this.flags & EffectFlags.DIRTY)) {
        this.flags |= EffectFlags.DIRTY
        this.dep.trigger()
      }
    }
  }
  
  get value() {
    // è„æ£€æŸ¥ï¼Œéœ€è¦é‡æ–°è®¡ç®—
    if (this.flags & EffectFlags.DIRTY) {
      this._value = this.effect.run()
      this.flags &= ~EffectFlags.DIRTY
    }
    
    this.dep.track()
    return this._value
  }
  
  set value(newValue) {
    this._setter(newValue)
  }
}

export function computed(getterOrOptions) {
  let getter, setter
  
  if (isFunction(getterOrOptions)) {
    getter = getterOrOptions
    setter = NOOP
  } else {
    getter = getterOrOptions.get
    setter = getterOrOptions.set
  }
  
  return new ComputedRefImpl(getter, setter, !setter)
}
```

## ä¸ƒã€æ‰¹é‡æ›´æ–°

```typescript
// packages/reactivity/src/effect.ts
let batchDepth = 0
let batchedSub: Subscriber | undefined

export function batch(sub: Subscriber) {
  sub.flags |= EffectFlags.NOTIFIED
  sub.next = batchedSub
  batchedSub = sub
}

export function startBatch() {
  batchDepth++
}

export function endBatch() {
  if (--batchDepth > 0) return
  
  let error
  while (batchedSub) {
    let e = batchedSub
    batchedSub = undefined
    
    while (e) {
      const next = e.next
      e.next = undefined
      e.flags &= ~EffectFlags.NOTIFIED
      
      if (e.flags & EffectFlags.ACTIVE) {
        try {
          e.trigger()
        } catch (err) {
          if (!error) error = err
        }
      }
      e = next
    }
  }
  
  if (error) throw error
}
```

## å…«ã€ä¾èµ–æ¸…ç†

```typescript
function prepareDeps(sub: Subscriber) {
  for (let link = sub.deps; link; link = link.nextDep) {
    // æ ‡è®°ä¸ºå¾…æ¸…ç†
    link.version = -1
    link.prevActiveLink = link.dep.activeLink
    link.dep.activeLink = link
  }
}

function cleanupDeps(sub: Subscriber) {
  let head
  let tail = sub.depsTail
  let link = tail
  
  while (link) {
    const prev = link.prevDep
    
    if (link.version === -1) {
      // æœªä½¿ç”¨çš„ä¾èµ–ï¼Œç§»é™¤
      if (link === tail) tail = prev
      removeSub(link)
      removeDep(link)
    } else {
      head = link
    }
    
    link.dep.activeLink = link.prevActiveLink
    link.prevActiveLink = undefined
    link = prev
  }
  
  sub.deps = head
  sub.depsTail = tail
}
```

## ä¹ã€å“åº”å¼å·¥å…·å‡½æ•°

```typescript
// åˆ¤æ–­æ˜¯å¦ä¸ºå“åº”å¼
export function isReactive(value) {
  return !!(value && value[ReactiveFlags.IS_REACTIVE])
}

// åˆ¤æ–­æ˜¯å¦ä¸º ref
export function isRef(r) {
  return r ? r[ReactiveFlags.IS_REF] === true : false
}

// è·å–åŸå§‹å€¼
export function toRaw(observed) {
  const raw = observed && observed[ReactiveFlags.RAW]
  return raw ? toRaw(raw) : observed
}

// æ ‡è®°ä¸ºéå“åº”å¼
export function markRaw(value) {
  def(value, ReactiveFlags.SKIP, true)
  return value
}

// è§£åŒ… ref
export function unref(ref) {
  return isRef(ref) ? ref.value : ref
}
```

## åã€è°ƒè¯•æŠ€å·§

### 10.1 å…³é”®æ–­ç‚¹

```typescript
// ä¾èµ–æ”¶é›†
packages/reactivity/src/dep.ts â†’ Dep.track

// è§¦å‘æ›´æ–°
packages/reactivity/src/dep.ts â†’ Dep.trigger

// effect æ‰§è¡Œ
packages/reactivity/src/effect.ts â†’ ReactiveEffect.run
```

### 10.2 è°ƒè¯•ç¤ºä¾‹

```typescript
import { reactive, effect } from 'vue'

const state = reactive({ count: 0 })

effect(() => {
  console.log('count:', state.count)
  // æ–­ç‚¹ï¼šæŸ¥çœ‹ activeSubã€deps
})

state.count++  // æ–­ç‚¹ï¼šæŸ¥çœ‹ trigger æµç¨‹
```

## åä¸€ã€å°ç»“

Vue3 å“åº”å¼ç³»ç»Ÿçš„æ ¸å¿ƒï¼š

1. **Proxy**ï¼šæ‹¦æˆªå¯¹è±¡æ“ä½œï¼Œå®ç°ä¾èµ–æ”¶é›†å’Œè§¦å‘
2. **Dep**ï¼šä¾èµ–å®¹å™¨ï¼Œç®¡ç†è®¢é˜…è€…é“¾è¡¨
3. **ReactiveEffect**ï¼šå‰¯ä½œç”¨ï¼Œè‡ªåŠ¨è¿½è¸ªä¾èµ–
4. **åŒå‘é“¾è¡¨**ï¼šé«˜æ•ˆçš„ä¾èµ–ç®¡ç†å’Œæ¸…ç†
5. **æ‰¹é‡æ›´æ–°**ï¼šåˆå¹¶å¤šæ¬¡æ›´æ–°ï¼Œæå‡æ€§èƒ½

---

> ğŸ“¦ æºç åœ°å€ï¼š[github.com/vuejs/core](https://github.com/vuejs/core)
> 
> ä¸‹ä¸€ç¯‡ï¼šè™šæ‹Ÿ DOM ä¸ Diff ç®—æ³•
> 
> å¦‚æœè§‰å¾—æœ‰å¸®åŠ©ï¼Œæ¬¢è¿ç‚¹èµæ”¶è— ğŸ‘
