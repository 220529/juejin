# Vue.js æºç æ­ç§˜ï¼ˆäº”ï¼‰ï¼šç¼–è¯‘å™¨åŸç†

> æœ¬æ–‡æ·±å…¥ compiler-core æºç ï¼Œè§£ææ¨¡æ¿ç¼–è¯‘çš„ parseã€transformã€codegen ä¸‰é˜¶æ®µã€‚

## ä¸€ã€ç¼–è¯‘æµç¨‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ç¼–è¯‘æµç¨‹                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  Template String                                            â”‚
â”‚       â”‚                                                     â”‚
â”‚       â–¼                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                â”‚
â”‚  â”‚  Parse  â”‚  â”€â”€â–º è¯æ³•åˆ†æ + è¯­æ³•åˆ†æ â”€â”€â–º AST               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                â”‚
â”‚       â”‚                                                     â”‚
â”‚       â–¼                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                              â”‚
â”‚  â”‚ Transform â”‚  â”€â”€â–º éå† ASTï¼Œåº”ç”¨è½¬æ¢æ’ä»¶ â”€â”€â–º ä¼˜åŒ–å AST   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                              â”‚
â”‚       â”‚                                                     â”‚
â”‚       â–¼                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                â”‚
â”‚  â”‚ Codegen â”‚  â”€â”€â–º ç”Ÿæˆ render å‡½æ•°ä»£ç                       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                â”‚
â”‚       â”‚                                                     â”‚
â”‚       â–¼                                                     â”‚
â”‚  Render Function                                            â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## äºŒã€compile å…¥å£

```typescript
// packages/compiler-core/src/compile.ts
export function baseCompile(
  source: string | RootNode,
  options: CompilerOptions = {}
): CodegenResult {
  // 1. Parseï¼šè§£ææ¨¡æ¿ä¸º AST
  const ast = isString(source) ? baseParse(source, options) : source
  
  // 2. Transformï¼šè½¬æ¢ AST
  transform(
    ast,
    extend({}, options, {
      nodeTransforms: [
        ...nodeTransforms,
        ...(options.nodeTransforms || [])
      ],
      directiveTransforms: extend(
        {},
        directiveTransforms,
        options.directiveTransforms || {}
      )
    })
  )
  
  // 3. Codegenï¼šç”Ÿæˆä»£ç 
  return generate(ast, extend({}, options, {
    prefixIdentifiers
  }))
}
```

## ä¸‰ã€Parse é˜¶æ®µ

### 3.1 AST èŠ‚ç‚¹ç±»å‹

```typescript
// packages/compiler-core/src/ast.ts
export enum NodeTypes {
  ROOT,                    // æ ¹èŠ‚ç‚¹
  ELEMENT,                 // å…ƒç´ 
  TEXT,                    // æ–‡æœ¬
  COMMENT,                 // æ³¨é‡Š
  SIMPLE_EXPRESSION,       // ç®€å•è¡¨è¾¾å¼
  INTERPOLATION,           // æ’å€¼ {{ }}
  ATTRIBUTE,               // å±æ€§
  DIRECTIVE,               // æŒ‡ä»¤
  
  // å®¹å™¨
  COMPOUND_EXPRESSION,     // å¤åˆè¡¨è¾¾å¼
  IF,                      // v-if
  IF_BRANCH,               // v-if åˆ†æ”¯
  FOR,                     // v-for
  TEXT_CALL,               // createTextVNode
  
  // codegen
  VNODE_CALL,              // createVNode
  JS_CALL_EXPRESSION,      // å‡½æ•°è°ƒç”¨
  JS_OBJECT_EXPRESSION,    // å¯¹è±¡è¡¨è¾¾å¼
  JS_PROPERTY,             // å¯¹è±¡å±æ€§
  JS_ARRAY_EXPRESSION,     // æ•°ç»„è¡¨è¾¾å¼
  JS_FUNCTION_EXPRESSION,  // å‡½æ•°è¡¨è¾¾å¼
  JS_CONDITIONAL_EXPRESSION, // æ¡ä»¶è¡¨è¾¾å¼
  JS_CACHE_EXPRESSION      // ç¼“å­˜è¡¨è¾¾å¼
}
```

### 3.2 baseParse

```typescript
// packages/compiler-core/src/parser.ts
export function baseParse(input: string, options: ParserOptions = {}): RootNode {
  const context = createParserContext(input, options)
  const start = getCursor(context)
  
  return createRoot(
    parseChildren(context, TextModes.DATA, []),
    getSelection(context, start)
  )
}

function createParserContext(content: string, options: ParserOptions): ParserContext {
  return {
    options: extend({}, defaultParserOptions, options),
    column: 1,
    line: 1,
    offset: 0,
    originalSource: content,
    source: content,
    inPre: false,
    inVPre: false
  }
}
```

### 3.3 parseChildren

```typescript
function parseChildren(
  context: ParserContext,
  mode: TextModes,
  ancestors: ElementNode[]
): TemplateChildNode[] {
  const nodes: TemplateChildNode[] = []
  
  while (!isEnd(context, mode, ancestors)) {
    const s = context.source
    let node: TemplateChildNode | undefined
    
    if (mode === TextModes.DATA || mode === TextModes.RCDATA) {
      if (startsWith(s, context.options.delimiters[0])) {
        // æ’å€¼ {{ }}
        node = parseInterpolation(context, mode)
      } else if (mode === TextModes.DATA && s[0] === '<') {
        if (s[1] === '!') {
          if (startsWith(s, '<!--')) {
            // æ³¨é‡Š
            node = parseComment(context)
          } else if (startsWith(s, '<!DOCTYPE')) {
            // DOCTYPE
            node = parseBogusComment(context)
          }
        } else if (s[1] === '/') {
          // ç»“æŸæ ‡ç­¾
          parseTag(context, TagType.End, parent)
          continue
        } else if (/[a-z]/i.test(s[1])) {
          // å…ƒç´ 
          node = parseElement(context, ancestors)
        }
      }
    }
    
    if (!node) {
      // æ–‡æœ¬
      node = parseText(context, mode)
    }
    
    if (isArray(node)) {
      nodes.push(...node)
    } else {
      nodes.push(node)
    }
  }
  
  return nodes
}
```

### 3.4 parseElement

```typescript
function parseElement(
  context: ParserContext,
  ancestors: ElementNode[]
): ElementNode | undefined {
  // è§£æå¼€å§‹æ ‡ç­¾
  const element = parseTag(context, TagType.Start, parent)
  
  // è‡ªé—­åˆæ ‡ç­¾
  if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
    return element
  }
  
  // é€’å½’è§£æå­èŠ‚ç‚¹
  ancestors.push(element)
  const mode = context.options.getTextMode(element, parent)
  const children = parseChildren(context, mode, ancestors)
  ancestors.pop()
  
  element.children = children
  
  // è§£æç»“æŸæ ‡ç­¾
  if (startsWithEndTagOpen(context.source, element.tag)) {
    parseTag(context, TagType.End, parent)
  }
  
  return element
}
```

### 3.5 parseTag

```typescript
function parseTag(
  context: ParserContext,
  type: TagType,
  parent: ElementNode | undefined
): ElementNode {
  // åŒ¹é…æ ‡ç­¾å
  const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source)!
  const tag = match[1]
  
  advanceBy(context, match[0].length)
  advanceSpaces(context)
  
  // è§£æå±æ€§
  const props = parseAttributes(context, type)
  
  // è‡ªé—­åˆ
  let isSelfClosing = false
  if (context.source.length === 0) {
    // error
  } else {
    isSelfClosing = startsWith(context.source, '/>')
    advanceBy(context, isSelfClosing ? 2 : 1)
  }
  
  // åˆ¤æ–­æ ‡ç­¾ç±»å‹
  let tagType = ElementTypes.ELEMENT
  if (tag === 'slot') {
    tagType = ElementTypes.SLOT
  } else if (tag === 'template') {
    if (props.some(p => p.type === NodeTypes.DIRECTIVE && isSpecialTemplateDirective(p.name))) {
      tagType = ElementTypes.TEMPLATE
    }
  } else if (isComponent(tag, props, context)) {
    tagType = ElementTypes.COMPONENT
  }
  
  return {
    type: NodeTypes.ELEMENT,
    tag,
    tagType,
    props,
    isSelfClosing,
    children: [],
    loc: getSelection(context, start)
  }
}
```

## å››ã€Transform é˜¶æ®µ

### 4.1 transform å…¥å£

```typescript
// packages/compiler-core/src/transform.ts
export function transform(root: RootNode, options: TransformOptions) {
  const context = createTransformContext(root, options)
  
  // éå† AST
  traverseNode(root, context)
  
  // é™æ€æå‡
  if (options.hoistStatic) {
    hoistStatic(root, context)
  }
  
  // åˆ›å»ºæ ¹èŠ‚ç‚¹ codegenNode
  if (!options.ssr) {
    createRootCodegen(root, context)
  }
  
  // æ”¶é›†å…ƒä¿¡æ¯
  root.helpers = new Set([...context.helpers.keys()])
  root.components = [...context.components]
  root.directives = [...context.directives]
  root.imports = context.imports
  root.hoists = context.hoists
  root.temps = context.temps
  root.cached = context.cached
}
```

### 4.2 traverseNode

```typescript
export function traverseNode(
  node: RootNode | TemplateChildNode,
  context: TransformContext
) {
  context.currentNode = node
  
  // åº”ç”¨ nodeTransforms
  const { nodeTransforms } = context
  const exitFns = []
  
  for (let i = 0; i < nodeTransforms.length; i++) {
    const onExit = nodeTransforms[i](node, context)
    if (onExit) {
      if (isArray(onExit)) {
        exitFns.push(...onExit)
      } else {
        exitFns.push(onExit)
      }
    }
    if (!context.currentNode) {
      // èŠ‚ç‚¹è¢«ç§»é™¤
      return
    }
    node = context.currentNode
  }
  
  // é€’å½’å¤„ç†å­èŠ‚ç‚¹
  switch (node.type) {
    case NodeTypes.COMMENT:
      context.helper(CREATE_COMMENT)
      break
    case NodeTypes.INTERPOLATION:
      context.helper(TO_DISPLAY_STRING)
      break
    case NodeTypes.IF:
      for (let i = 0; i < node.branches.length; i++) {
        traverseNode(node.branches[i], context)
      }
      break
    case NodeTypes.IF_BRANCH:
    case NodeTypes.FOR:
    case NodeTypes.ELEMENT:
    case NodeTypes.ROOT:
      traverseChildren(node, context)
      break
  }
  
  // æ‰§è¡Œé€€å‡ºå‡½æ•°ï¼ˆé€†åºï¼‰
  context.currentNode = node
  let i = exitFns.length
  while (i--) {
    exitFns[i]()
  }
}
```

### 4.3 æ ¸å¿ƒè½¬æ¢æ’ä»¶

```typescript
// å†…ç½® nodeTransforms
export const nodeTransforms = [
  transformOnce,           // v-once
  transformIf,             // v-if/v-else-if/v-else
  transformMemo,           // v-memo
  transformFor,            // v-for
  transformExpression,     // è¡¨è¾¾å¼
  transformSlotOutlet,     // <slot>
  transformElement,        // å…ƒç´ 
  trackSlotScopes,         // æ’æ§½ä½œç”¨åŸŸ
  transformText            // æ–‡æœ¬
]

// å†…ç½® directiveTransforms
export const directiveTransforms = {
  bind: transformBind,     // v-bind
  cloak: noopDirectiveTransform,
  html: transformVHtml,    // v-html
  text: transformVText,    // v-text
  model: transformModel,   // v-model
  on: transformOn,         // v-on
  show: transformShow      // v-show
}
```

### 4.4 transformElement

```typescript
// packages/compiler-core/src/transforms/transformElement.ts
export const transformElement: NodeTransform = (node, context) => {
  return function postTransformElement() {
    const { tag, props } = node
    
    // åˆ†æ props
    let vnodeProps
    let vnodePatchFlag
    let vnodeDynamicProps
    let vnodeDirectives
    
    // å¤„ç† props
    if (props.length > 0) {
      const propsBuildResult = buildProps(node, context)
      vnodeProps = propsBuildResult.props
      vnodePatchFlag = propsBuildResult.patchFlag
      vnodeDynamicProps = propsBuildResult.dynamicPropNames
      vnodeDirectives = propsBuildResult.directives
    }
    
    // å¤„ç† children
    let vnodeChildren
    if (node.children.length > 0) {
      if (node.children.length === 1) {
        const child = node.children[0]
        if (child.type === NodeTypes.TEXT) {
          vnodeChildren = child
        } else {
          vnodeChildren = node.children
        }
      } else {
        vnodeChildren = node.children
      }
    }
    
    // åˆ›å»º codegenNode
    node.codegenNode = createVNodeCall(
      context,
      vnodeTag,
      vnodeProps,
      vnodeChildren,
      vnodePatchFlag,
      vnodeDynamicProps,
      vnodeDirectives,
      shouldUseBlock(node, vnodePatchFlag)
    )
  }
}
```

## äº”ã€Codegen é˜¶æ®µ

### 5.1 generate å…¥å£

```typescript
// packages/compiler-core/src/codegen.ts
export function generate(
  ast: RootNode,
  options: CodegenOptions = {}
): CodegenResult {
  const context = createCodegenContext(ast, options)
  const { mode, push, indent, deindent, newline } = context
  
  // ç”Ÿæˆå‰ç½®ä»£ç 
  genFunctionPreamble(ast, context)
  
  // ç”Ÿæˆ render å‡½æ•°
  const functionName = 'render'
  const args = ['_ctx', '_cache']
  
  push(`function ${functionName}(${args.join(', ')}) {`)
  indent()
  
  // with æ¨¡å¼
  if (!options.prefixIdentifiers) {
    push(`with (_ctx) {`)
    indent()
  }
  
  // ç”Ÿæˆ helpers
  if (ast.helpers.size > 0) {
    push(`const { ${[...ast.helpers].map(s => `${helperNameMap[s]}: _${helperNameMap[s]}`).join(', ')} } = _Vue`)
    newline()
  }
  
  // ç”Ÿæˆ return
  push(`return `)
  if (ast.codegenNode) {
    genNode(ast.codegenNode, context)
  } else {
    push(`null`)
  }
  
  if (!options.prefixIdentifiers) {
    deindent()
    push(`}`)
  }
  
  deindent()
  push(`}`)
  
  return {
    ast,
    code: context.code,
    preamble: '',
    map: context.map ? context.map.toJSON() : undefined
  }
}
```

### 5.2 genNode

```typescript
function genNode(node: CodegenNode | symbol | string, context: CodegenContext) {
  if (isString(node)) {
    context.push(node)
    return
  }
  if (isSymbol(node)) {
    context.push(context.helper(node))
    return
  }
  
  switch (node.type) {
    case NodeTypes.ELEMENT:
    case NodeTypes.IF:
    case NodeTypes.FOR:
      genNode(node.codegenNode!, context)
      break
    case NodeTypes.TEXT:
      genText(node, context)
      break
    case NodeTypes.SIMPLE_EXPRESSION:
      genExpression(node, context)
      break
    case NodeTypes.INTERPOLATION:
      genInterpolation(node, context)
      break
    case NodeTypes.COMPOUND_EXPRESSION:
      genCompoundExpression(node, context)
      break
    case NodeTypes.VNODE_CALL:
      genVNodeCall(node, context)
      break
    case NodeTypes.JS_CALL_EXPRESSION:
      genCallExpression(node, context)
      break
    case NodeTypes.JS_OBJECT_EXPRESSION:
      genObjectExpression(node, context)
      break
    case NodeTypes.JS_ARRAY_EXPRESSION:
      genArrayExpression(node, context)
      break
    case NodeTypes.JS_FUNCTION_EXPRESSION:
      genFunctionExpression(node, context)
      break
    case NodeTypes.JS_CONDITIONAL_EXPRESSION:
      genConditionalExpression(node, context)
      break
  }
}
```

### 5.3 genVNodeCall

```typescript
function genVNodeCall(node: VNodeCall, context: CodegenContext) {
  const { push, helper } = context
  const {
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking
  } = node
  
  if (directives) {
    push(helper(WITH_DIRECTIVES) + `(`)
  }
  if (isBlock) {
    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `)
  }
  
  // createElementVNode / createBlock
  const callHelper = isBlock
    ? getVNodeBlockHelper(context.inSSR, isComponent)
    : getVNodeHelper(context.inSSR, isComponent)
  
  push(helper(callHelper) + `(`)
  
  // ç”Ÿæˆå‚æ•°
  genNodeList(
    genNullableArgs([tag, props, children, patchFlag, dynamicProps]),
    context
  )
  
  push(`)`)
  
  if (isBlock) {
    push(`)`)
  }
  if (directives) {
    push(`, `)
    genNode(directives, context)
    push(`)`)
  }
}
```

## å…­ã€ç¼–è¯‘ç¤ºä¾‹

### è¾“å…¥æ¨¡æ¿

```html
<div id="app">
  <span>{{ msg }}</span>
  <button @click="handleClick">Click</button>
</div>
```

### è¾“å‡ºä»£ç 

```javascript
import { toDisplayString as _toDisplayString, createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", { id: "app" }, [
    _createElementVNode("span", null, _toDisplayString(_ctx.msg), 1 /* TEXT */),
    _createElementVNode("button", { onClick: _ctx.handleClick }, "Click", 8 /* PROPS */, ["onClick"])
  ]))
}
```

## ä¸ƒã€ç¼–è¯‘ä¼˜åŒ–

### 7.1 é™æ€æå‡

```typescript
// é™æ€èŠ‚ç‚¹æå‡åˆ° render å‡½æ•°å¤–
const _hoisted_1 = { id: "app" }
const _hoisted_2 = /*#__PURE__*/_createElementVNode("span", null, "static text", -1 /* HOISTED */)

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", _hoisted_1, [
    _hoisted_2,
    _createElementVNode("span", null, _toDisplayString(_ctx.msg), 1)
  ]))
}
```

### 7.2 PatchFlags

```typescript
// æ ‡è®°åŠ¨æ€å†…å®¹ç±»å‹
TEXT = 1           // åŠ¨æ€æ–‡æœ¬
CLASS = 2          // åŠ¨æ€ class
STYLE = 4          // åŠ¨æ€ style
PROPS = 8          // åŠ¨æ€ props
FULL_PROPS = 16    // æœ‰åŠ¨æ€ key
NEED_HYDRATION = 32
STABLE_FRAGMENT = 64
KEYED_FRAGMENT = 128
UNKEYED_FRAGMENT = 256
NEED_PATCH = 512
DYNAMIC_SLOTS = 1024
HOISTED = -1       // é™æ€æå‡
BAIL = -2          // é€€å‡ºä¼˜åŒ–
```

## å…«ã€å°ç»“

Vue3 ç¼–è¯‘å™¨çš„æ ¸å¿ƒï¼š

1. **Parse**ï¼šè¯æ³•åˆ†æ + è¯­æ³•åˆ†æï¼Œç”Ÿæˆ AST
2. **Transform**ï¼šéå† ASTï¼Œåº”ç”¨è½¬æ¢æ’ä»¶ï¼Œç”Ÿæˆ codegenNode
3. **Codegen**ï¼šé€’å½’ç”Ÿæˆ render å‡½æ•°ä»£ç 
4. **ä¼˜åŒ–**ï¼šé™æ€æå‡ã€PatchFlagsã€Block Tree

---

> ğŸ“¦ æºç åœ°å€ï¼š[github.com/vuejs/core](https://github.com/vuejs/core)
> 
> ä¸‹ä¸€ç¯‡ï¼šScheduler è°ƒåº¦å™¨
> 
> å¦‚æœè§‰å¾—æœ‰å¸®åŠ©ï¼Œæ¬¢è¿ç‚¹èµæ”¶è— ğŸ‘
