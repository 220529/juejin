# è·¨å¹³å°æ–‡ä»¶å·¥å…·ç®±æŠ€æœ¯æ–¹æ¡ˆ

> å¯è§†åŒ–æ–‡ä»¶ç®¡ç†å·¥å…·ï¼Œæ”¯æŒ Mac/Windowsï¼Œæ–‡ä»¶ç»Ÿè®¡ã€å»é‡ã€è§†é¢‘å¤„ç†ç­‰åŠŸèƒ½

## ä¸€ã€éœ€æ±‚è¯´æ˜

### è·¨å¹³å°è¦æ±‚
- âœ… æ”¯æŒ macOS
- âœ… æ”¯æŒ Windows
- âœ… æ”¯æŒ Linuxï¼ˆå¯é€‰ï¼‰

### æ ¸å¿ƒåŠŸèƒ½

#### 1. æ–‡ä»¶æŸ¥çœ‹ï¼ˆç»Ÿè®¡ï¼‰
- é€‰æ‹©/æ‹–å…¥ä¸€ä¸ªæ–‡ä»¶å¤¹
- **é€’å½’éå†**æ‰€æœ‰å­æ–‡ä»¶å¤¹
- è¾“å‡ºï¼šå„æ–‡ä»¶æ ¼å¼ã€å¯¹åº”ä¸ªæ•°ã€æ€»å¤§å°

#### 2. æ–‡ä»¶å»é‡
- é€‰æ‹©ä¸€ä¸ªæ–‡ä»¶å¤¹ï¼Œé€’å½’æ‰«ææ‰€æœ‰æ–‡ä»¶
- æ‰¾å‡ºé‡å¤æ–‡ä»¶ï¼ˆåŸºäºå†…å®¹ MD5ï¼‰
- **æ ‡å‡ºé‡å¤æ–‡ä»¶ï¼Œå±•ç¤ºç»™ç”¨æˆ·ç¡®è®¤**
- ç”¨æˆ·å‹¾é€‰åç‚¹å‡»"åˆ é™¤"ï¼Œæ‰æ‰§è¡Œåˆ é™¤æ“ä½œ
- æ”¯æŒé¢„è§ˆé‡å¤æ–‡ä»¶

#### 3. è§†é¢‘æˆªå–
- é€‰æ‹©è§†é¢‘æ–‡ä»¶
- è®¾ç½®å¼€å§‹æ—¶é—´ã€ç»“æŸæ—¶é—´ï¼ˆå¦‚ 00:01:30 åˆ° 00:02:45ï¼‰
- å¯¼å‡ºæˆªå–åçš„è§†é¢‘ç‰‡æ®µ

#### 4. è§†é¢‘æ¸…æ™°åº¦è¿˜åŸï¼ˆAI è¶…åˆ†ï¼‰
- é€‰æ‹©æ¨¡ç³Š/ä½åˆ†è¾¨ç‡è§†é¢‘
- AI å¤„ç†ï¼Œè¾“å‡ºé«˜æ¸…ç‰ˆæœ¬
- æ”¯æŒ 2x / 4x æ”¾å¤§

## äºŒã€æŠ€æœ¯é€‰å‹

### ä¸ºä»€ä¹ˆé€‰ Tauriï¼Ÿ

| å¯¹æ¯”é¡¹ | Electron | Tauri | çº¯ Web |
|--------|----------|-------|--------|
| åŒ…ä½“å¤§å° | 150MB+ | 5-10MB | 0 |
| å†…å­˜å ç”¨ | é«˜ | ä½ | - |
| æ–‡ä»¶ç³»ç»Ÿè®¿é—® | âœ… | âœ… | âš ï¸ å—é™ |
| è§†é¢‘å¤„ç† | âœ… è°ƒç”¨ FFmpeg | âœ… è°ƒç”¨ FFmpeg | âŒ |
| è·¨å¹³å° | âœ… | âœ… | âœ… |
| å¼€å‘è¯­è¨€ | JS | Rust + JS | JS |

**ç»“è®º**ï¼šTauri åŒ…ä½“å°ã€æ€§èƒ½å¥½ï¼Œé€‚åˆè¿™ç±»å·¥å…·å‹åº”ç”¨ã€‚

### æŠ€æœ¯æ ˆ

```
å‰ç«¯ï¼šReact/Vue + TypeScript + TailwindCSS
åç«¯ï¼šTauri (Rust)
è§†é¢‘å¤„ç†ï¼šFFmpegï¼ˆå†…ç½®æˆ–ç³»ç»Ÿè°ƒç”¨ï¼‰
æ–‡ä»¶å“ˆå¸Œï¼šRust åŸç”Ÿå®ç°ï¼ˆæ€§èƒ½å¥½ï¼‰
AI è¶…åˆ†ï¼šReal-ESRGAN / Topaz Video AI API
```

## ä¸‰ã€æ¶æ„è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Tauri åº”ç”¨                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                   å‰ç«¯ (WebView)                    â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚  â”‚æ–‡ä»¶ç»Ÿè®¡  â”‚ â”‚æ–‡ä»¶å»é‡  â”‚ â”‚è§†é¢‘å¤„ç†  â”‚ â”‚ è®¾ç½®    â”‚  â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                          â”‚ Tauri IPC                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                   Rust åç«¯                         â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚  â”‚æ–‡ä»¶éå†  â”‚ â”‚MD5è®¡ç®—   â”‚ â”‚FFmpeg   â”‚ â”‚AIè¶…åˆ†   â”‚  â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## å››ã€æ ¸å¿ƒåŠŸèƒ½å®ç°

### 4.1 æ–‡ä»¶ç»Ÿè®¡

**Rust åç«¯**ï¼ˆé«˜æ€§èƒ½é€’å½’éå†ï¼‰ï¼š
```rust
// src-tauri/src/commands/file_stats.rs
use std::collections::HashMap;
use std::path::Path;
use walkdir::WalkDir;
use serde::Serialize;

#[derive(Serialize)]
pub struct FileStats {
    pub extension: String,
    pub count: u64,
    pub total_size: u64,
}

#[tauri::command]
pub fn scan_directory(path: String) -> Result<Vec<FileStats>, String> {
    let mut stats: HashMap<String, (u64, u64)> = HashMap::new();
    
    for entry in WalkDir::new(&path).into_iter().filter_map(|e| e.ok()) {
        if entry.file_type().is_file() {
            let ext = entry.path()
                .extension()
                .map(|e| e.to_string_lossy().to_lowercase())
                .unwrap_or_default();
            
            let size = entry.metadata().map(|m| m.len()).unwrap_or(0);
            
            let stat = stats.entry(ext).or_insert((0, 0));
            stat.0 += 1;
            stat.1 += size;
        }
    }
    
    let mut result: Vec<FileStats> = stats
        .into_iter()
        .map(|(ext, (count, size))| FileStats {
            extension: if ext.is_empty() { "(æ— æ‰©å±•å)".into() } else { format!(".{}", ext) },
            count,
            total_size: size,
        })
        .collect();
    
    result.sort_by(|a, b| b.count.cmp(&a.count));
    Ok(result)
}
```

**å‰ç«¯è°ƒç”¨**ï¼š
```typescript
// src/pages/FileStats.tsx
import { invoke } from '@tauri-apps/api/tauri';
import { open } from '@tauri-apps/api/dialog';

interface FileStats {
  extension: string;
  count: number;
  total_size: number;
}

async function selectAndScan() {
  const selected = await open({ directory: true });
  if (selected) {
    const stats = await invoke<FileStats[]>('scan_directory', { path: selected });
    setStats(stats);
  }
}
```

### 4.2 æ–‡ä»¶å»é‡ï¼ˆå¸¦ç”¨æˆ·ç¡®è®¤ï¼‰

**Rust åç«¯**ï¼š
```rust
// src-tauri/src/commands/dedup.rs
use md5::{Md5, Digest};
use std::collections::HashMap;
use std::fs::{self, File};
use std::io::Read;
use std::path::Path;
use walkdir::WalkDir;
use serde::Serialize;

#[derive(Serialize, Clone)]
pub struct FileInfo {
    pub path: String,
    pub name: String,
    pub size: u64,
    pub modified: u64,  // ä¿®æ”¹æ—¶é—´æˆ³
}

#[derive(Serialize)]
pub struct DuplicateGroup {
    pub hash: String,
    pub size: u64,
    pub files: Vec<FileInfo>,  // é‡å¤çš„æ–‡ä»¶åˆ—è¡¨
}

/// ç¬¬ä¸€æ­¥ï¼šæ‰«æå¹¶è¿”å›é‡å¤æ–‡ä»¶ï¼ˆä¸åˆ é™¤ï¼Œç­‰ç”¨æˆ·ç¡®è®¤ï¼‰
#[tauri::command]
pub fn find_duplicates(path: String) -> Result<Vec<DuplicateGroup>, String> {
    let mut size_map: HashMap<u64, Vec<String>> = HashMap::new();
    
    // 1. å…ˆæŒ‰æ–‡ä»¶å¤§å°åˆ†ç»„ï¼ˆå¿«é€Ÿç­›é€‰ï¼‰
    for entry in WalkDir::new(&path).into_iter().filter_map(|e| e.ok()) {
        if entry.file_type().is_file() {
            if let Ok(meta) = entry.metadata() {
                let size = meta.len();
                if size > 0 {  // å¿½ç•¥ç©ºæ–‡ä»¶
                    size_map.entry(size).or_default()
                        .push(entry.path().to_string_lossy().to_string());
                }
            }
        }
    }
    
    // 2. åªå¯¹å¤§å°ç›¸åŒçš„æ–‡ä»¶è®¡ç®— MD5
    let mut hash_map: HashMap<String, Vec<FileInfo>> = HashMap::new();
    
    for (size, files) in size_map {
        if files.len() < 2 { continue; }  // å¤§å°å”¯ä¸€ï¼Œä¸å¯èƒ½é‡å¤
        
        for file_path in files {
            if let Ok(hash) = calculate_md5(Path::new(&file_path)) {
                let meta = fs::metadata(&file_path).ok();
                let file_info = FileInfo {
                    name: Path::new(&file_path)
                        .file_name()
                        .map(|n| n.to_string_lossy().to_string())
                        .unwrap_or_default(),
                    path: file_path,
                    size,
                    modified: meta.and_then(|m| m.modified().ok())
                        .and_then(|t| t.duration_since(std::time::UNIX_EPOCH).ok())
                        .map(|d| d.as_secs())
                        .unwrap_or(0),
                };
                hash_map.entry(hash).or_default().push(file_info);
            }
        }
    }
    
    // 3. åªè¿”å›æœ‰é‡å¤çš„ç»„
    let duplicates: Vec<DuplicateGroup> = hash_map
        .into_iter()
        .filter(|(_, files)| files.len() > 1)
        .map(|(hash, files)| DuplicateGroup {
            hash,
            size: files[0].size,
            files,
        })
        .collect();
    
    Ok(duplicates)
}

/// ç¬¬äºŒæ­¥ï¼šç”¨æˆ·ç¡®è®¤åï¼Œåˆ é™¤æŒ‡å®šæ–‡ä»¶
#[tauri::command]
pub fn delete_files(paths: Vec<String>) -> Result<u32, String> {
    let mut deleted = 0;
    for path in paths {
        if fs::remove_file(&path).is_ok() {
            deleted += 1;
        }
    }
    Ok(deleted)
}

fn calculate_md5(path: &Path) -> Result<String, String> {
    let mut file = File::open(path).map_err(|e| e.to_string())?;
    let mut hasher = Md5::new();
    let mut buffer = [0u8; 65536];  // 64KB buffer
    
    loop {
        let bytes_read = file.read(&mut buffer).map_err(|e| e.to_string())?;
        if bytes_read == 0 { break; }
        hasher.update(&buffer[..bytes_read]);
    }
    
    Ok(format!("{:x}", hasher.finalize()))
}
```

**å‰ç«¯äº¤äº’æµç¨‹**ï¼š
```typescript
// src/pages/Dedup.tsx
import { useState } from 'react';
import { invoke } from '@tauri-apps/api/tauri';
import { open, confirm } from '@tauri-apps/api/dialog';

interface FileInfo {
  path: string;
  name: string;
  size: number;
  modified: number;
}

interface DuplicateGroup {
  hash: string;
  size: number;
  files: FileInfo[];
}

export default function Dedup() {
  const [groups, setGroups] = useState<DuplicateGroup[]>([]);
  const [selected, setSelected] = useState<Set<string>>(new Set());
  const [scanning, setScanning] = useState(false);

  // 1. é€‰æ‹©æ–‡ä»¶å¤¹å¹¶æ‰«æ
  async function scanFolder() {
    const folder = await open({ directory: true, title: 'é€‰æ‹©è¦æ‰«æçš„æ–‡ä»¶å¤¹' });
    if (!folder) return;

    setScanning(true);
    try {
      const result = await invoke<DuplicateGroup[]>('find_duplicates', { path: folder });
      setGroups(result);
      setSelected(new Set());
    } finally {
      setScanning(false);
    }
  }

  // 2. åˆ‡æ¢é€‰ä¸­çŠ¶æ€
  function toggleSelect(path: string) {
    const newSelected = new Set(selected);
    if (newSelected.has(path)) {
      newSelected.delete(path);
    } else {
      newSelected.add(path);
    }
    setSelected(newSelected);
  }

  // 3. æ™ºèƒ½é€‰æ‹©ï¼šæ¯ç»„ä¿ç•™æœ€æ—©çš„ï¼Œé€‰ä¸­å…¶ä½™çš„
  function autoSelect() {
    const toDelete = new Set<string>();
    groups.forEach(group => {
      const sorted = [...group.files].sort((a, b) => a.modified - b.modified);
      sorted.slice(1).forEach(f => toDelete.add(f.path));  // ä¿ç•™ç¬¬ä¸€ä¸ªï¼ˆæœ€æ—©ï¼‰
    });
    setSelected(toDelete);
  }

  // 4. ç¡®è®¤åˆ é™¤
  async function deleteSelected() {
    if (selected.size === 0) return;

    const confirmed = await confirm(
      `ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${selected.size} ä¸ªæ–‡ä»¶å—ï¼Ÿ\næ­¤æ“ä½œä¸å¯æ¢å¤ï¼`,
      { title: 'ç¡®è®¤åˆ é™¤', type: 'warning' }
    );

    if (confirmed) {
      const deleted = await invoke<number>('delete_files', { paths: Array.from(selected) });
      alert(`æˆåŠŸåˆ é™¤ ${deleted} ä¸ªæ–‡ä»¶`);
      // é‡æ–°æ‰«æ
      scanFolder();
    }
  }

  return (
    <div className="dedup-page">
      <div className="toolbar">
        <button onClick={scanFolder} disabled={scanning}>
          {scanning ? 'æ‰«æä¸­...' : 'é€‰æ‹©æ–‡ä»¶å¤¹'}
        </button>
        <button onClick={autoSelect} disabled={groups.length === 0}>
          æ™ºèƒ½é€‰æ‹©ï¼ˆä¿ç•™æœ€æ—©ï¼‰
        </button>
        <button onClick={deleteSelected} disabled={selected.size === 0} className="danger">
          åˆ é™¤é€‰ä¸­ ({selected.size})
        </button>
      </div>

      {groups.length > 0 && (
        <div className="summary">
          å‘ç° {groups.length} ç»„é‡å¤æ–‡ä»¶ï¼Œå…± {groups.reduce((sum, g) => sum + g.files.length, 0)} ä¸ªæ–‡ä»¶
        </div>
      )}

      <div className="duplicate-list">
        {groups.map((group, idx) => (
          <div key={group.hash} className="duplicate-group">
            <div className="group-header">
              ç¬¬ {idx + 1} ç»„ | {formatSize(group.size)} | {group.files.length} ä¸ªæ–‡ä»¶
            </div>
            {group.files.map(file => (
              <div 
                key={file.path} 
                className={`file-item ${selected.has(file.path) ? 'selected' : ''}`}
                onClick={() => toggleSelect(file.path)}
              >
                <input 
                  type="checkbox" 
                  checked={selected.has(file.path)}
                  onChange={() => toggleSelect(file.path)}
                />
                <span className="file-name">{file.name}</span>
                <span className="file-path">{file.path}</span>
              </div>
            ))}
          </div>
        ))}
      </div>
    </div>
  );
}
```

### 4.3 è§†é¢‘æˆªå–ï¼ˆæŒ‡å®šæ—¶é—´æ®µï¼‰

**Rust åç«¯**ï¼š
```rust
// src-tauri/src/commands/video.rs
use std::process::Command;
use tauri::Window;

/// è§£ææ—¶é—´å­—ç¬¦ä¸²ä¸ºç§’æ•°ï¼Œæ”¯æŒå¤šç§æ ¼å¼
/// "90" -> 90ç§’
/// "1:30" -> 90ç§’  
/// "00:01:30" -> 90ç§’
fn parse_time(time_str: &str) -> Result<f64, String> {
    let parts: Vec<&str> = time_str.split(':').collect();
    match parts.len() {
        1 => parts[0].parse::<f64>().map_err(|e| e.to_string()),
        2 => {
            let mins: f64 = parts[0].parse().map_err(|e: std::num::ParseFloatError| e.to_string())?;
            let secs: f64 = parts[1].parse().map_err(|e: std::num::ParseFloatError| e.to_string())?;
            Ok(mins * 60.0 + secs)
        }
        3 => {
            let hours: f64 = parts[0].parse().map_err(|e: std::num::ParseFloatError| e.to_string())?;
            let mins: f64 = parts[1].parse().map_err(|e: std::num::ParseFloatError| e.to_string())?;
            let secs: f64 = parts[2].parse().map_err(|e: std::num::ParseFloatError| e.to_string())?;
            Ok(hours * 3600.0 + mins * 60.0 + secs)
        }
        _ => Err("æ—¶é—´æ ¼å¼é”™è¯¯".into()),
    }
}

#[tauri::command]
pub async fn cut_video(
    input: String,
    output: String,
    start_time: String,  // "00:01:30" æˆ– "90"
    end_time: String,    // "00:02:45" æˆ– "165"
    window: Window,
) -> Result<String, String> {
    let start_secs = parse_time(&start_time)?;
    let end_secs = parse_time(&end_time)?;
    
    if end_secs <= start_secs {
        return Err("ç»“æŸæ—¶é—´å¿…é¡»å¤§äºå¼€å§‹æ—¶é—´".into());
    }
    
    let duration = end_secs - start_secs;
    
    // ä½¿ç”¨ -ss åœ¨ -i å‰é¢å¯ä»¥å¿«é€Ÿå®šä½ï¼ˆseekï¼‰
    let status = Command::new("ffmpeg")
        .args([
            "-y",  // è¦†ç›–è¾“å‡ºæ–‡ä»¶
            "-ss", &format!("{}", start_secs),
            "-i", &input,
            "-t", &format!("{}", duration),
            "-c", "copy",  // æ— æŸæˆªå–ï¼Œé€Ÿåº¦å¿«
            "-avoid_negative_ts", "make_zero",
            &output
        ])
        .status()
        .map_err(|e| format!("FFmpeg æ‰§è¡Œå¤±è´¥: {}", e))?;
    
    if status.success() {
        Ok(output)
    } else {
        Err("è§†é¢‘æˆªå–å¤±è´¥".into())
    }
}

/// è·å–è§†é¢‘æ—¶é•¿ï¼ˆç”¨äºå‰ç«¯æ˜¾ç¤ºï¼‰
#[tauri::command]
pub fn get_video_duration(path: String) -> Result<f64, String> {
    let output = Command::new("ffprobe")
        .args([
            "-v", "error",
            "-show_entries", "format=duration",
            "-of", "default=noprint_wrappers=1:nokey=1",
            &path
        ])
        .output()
        .map_err(|e| e.to_string())?;
    
    let duration_str = String::from_utf8_lossy(&output.stdout);
    duration_str.trim().parse::<f64>().map_err(|e| e.to_string())
}
```

**å‰ç«¯ç•Œé¢**ï¼š
```typescript
// src/pages/VideoCut.tsx
import { useState } from 'react';
import { invoke } from '@tauri-apps/api/tauri';
import { open, save } from '@tauri-apps/api/dialog';

export default function VideoCut() {
  const [videoPath, setVideoPath] = useState('');
  const [duration, setDuration] = useState(0);
  const [startTime, setStartTime] = useState('00:00:00');
  const [endTime, setEndTime] = useState('00:00:00');
  const [processing, setProcessing] = useState(false);

  async function selectVideo() {
    const file = await open({
      filters: [{ name: 'è§†é¢‘æ–‡ä»¶', extensions: ['mp4', 'mov', 'avi', 'mkv', 'wmv', 'flv'] }]
    });
    if (file && typeof file === 'string') {
      setVideoPath(file);
      const dur = await invoke<number>('get_video_duration', { path: file });
      setDuration(dur);
      setEndTime(formatTime(dur));
    }
  }

  async function cutVideo() {
    const outputPath = await save({
      defaultPath: 'output.mp4',
      filters: [{ name: 'è§†é¢‘æ–‡ä»¶', extensions: ['mp4'] }]
    });
    if (!outputPath) return;

    setProcessing(true);
    try {
      await invoke('cut_video', {
        input: videoPath,
        output: outputPath,
        startTime,
        endTime,
      });
      alert('æˆªå–å®Œæˆï¼');
    } catch (e) {
      alert('æˆªå–å¤±è´¥: ' + e);
    } finally {
      setProcessing(false);
    }
  }

  return (
    <div className="video-cut-page">
      <button onClick={selectVideo}>é€‰æ‹©è§†é¢‘</button>
      
      {videoPath && (
        <>
          <video src={`file://${videoPath}`} controls style={{ maxWidth: '100%' }} />
          <p>è§†é¢‘æ—¶é•¿: {formatTime(duration)}</p>
          
          <div className="time-inputs">
            <label>
              å¼€å§‹æ—¶é—´:
              <input value={startTime} onChange={e => setStartTime(e.target.value)} placeholder="00:01:30" />
            </label>
            <label>
              ç»“æŸæ—¶é—´:
              <input value={endTime} onChange={e => setEndTime(e.target.value)} placeholder="00:02:45" />
            </label>
          </div>
          
          <button onClick={cutVideo} disabled={processing}>
            {processing ? 'å¤„ç†ä¸­...' : 'å¼€å§‹æˆªå–'}
          </button>
        </>
      )}
    </div>
  );
}

function formatTime(seconds: number): string {
  const h = Math.floor(seconds / 3600);
  const m = Math.floor((seconds % 3600) / 60);
  const s = Math.floor(seconds % 60);
  return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
}
```

### 4.4 è§†é¢‘æ¸…æ™°åº¦è¿˜åŸï¼ˆAI è¶…åˆ†è¾¨ç‡ï¼‰

æœ‰ä¸¤ç§å®ç°æ–¹æ¡ˆï¼š

#### æ–¹æ¡ˆ Aï¼šæœ¬åœ° Real-ESRGANï¼ˆå…è´¹ï¼Œéœ€è¦ GPUï¼‰

```rust
// src-tauri/src/commands/upscale.rs
use std::process::Command;
use std::path::Path;
use std::fs;

/// è§†é¢‘è¶…åˆ†è¾¨ç‡å¤„ç†æµç¨‹ï¼š
/// 1. è§†é¢‘æ‹†å¸§ -> ä¸´æ—¶å›¾ç‰‡åºåˆ—
/// 2. é€å¸§ AI è¶…åˆ†
/// 3. å›¾ç‰‡åºåˆ—åˆæˆè§†é¢‘
/// 4. åˆå¹¶åŸéŸ³è½¨
#[tauri::command]
pub async fn upscale_video(
    input: String,
    output: String,
    scale: u32,  // 2 æˆ– 4
    window: tauri::Window,
) -> Result<String, String> {
    let temp_dir = std::env::temp_dir().join("video_upscale");
    let frames_dir = temp_dir.join("frames");
    let upscaled_dir = temp_dir.join("upscaled");
    
    // æ¸…ç†å¹¶åˆ›å»ºä¸´æ—¶ç›®å½•
    let _ = fs::remove_dir_all(&temp_dir);
    fs::create_dir_all(&frames_dir).map_err(|e| e.to_string())?;
    fs::create_dir_all(&upscaled_dir).map_err(|e| e.to_string())?;
    
    // 1. æå–å¸§
    window.emit("upscale_progress", "æ­£åœ¨æå–è§†é¢‘å¸§...").ok();
    let status = Command::new("ffmpeg")
        .args([
            "-i", &input,
            "-qscale:v", "2",
            &format!("{}/frame_%06d.png", frames_dir.display())
        ])
        .status()
        .map_err(|e| e.to_string())?;
    
    if !status.success() {
        return Err("æå–å¸§å¤±è´¥".into());
    }
    
    // 2. AI è¶…åˆ†ï¼ˆä½¿ç”¨ Real-ESRGANï¼‰
    window.emit("upscale_progress", "æ­£åœ¨ AI è¶…åˆ†å¤„ç†...").ok();
    let realesrgan_path = get_realesrgan_path();
    let status = Command::new(&realesrgan_path)
        .args([
            "-i", &frames_dir.to_string_lossy(),
            "-o", &upscaled_dir.to_string_lossy(),
            "-s", &scale.to_string(),
            "-n", "realesrgan-x4plus",  // æ¨¡å‹åç§°
        ])
        .status()
        .map_err(|e| e.to_string())?;
    
    if !status.success() {
        return Err("AI è¶…åˆ†å¤„ç†å¤±è´¥".into());
    }
    
    // 3. è·å–åŸè§†é¢‘å¸§ç‡
    let fps = get_video_fps(&input)?;
    
    // 4. åˆæˆè§†é¢‘ï¼ˆä¸å«éŸ³é¢‘ï¼‰
    window.emit("upscale_progress", "æ­£åœ¨åˆæˆè§†é¢‘...").ok();
    let temp_video = temp_dir.join("temp_no_audio.mp4");
    let status = Command::new("ffmpeg")
        .args([
            "-framerate", &fps.to_string(),
            "-i", &format!("{}/frame_%06d.png", upscaled_dir.display()),
            "-c:v", "libx264",
            "-crf", "18",
            "-pix_fmt", "yuv420p",
            &temp_video.to_string_lossy()
        ])
        .status()
        .map_err(|e| e.to_string())?;
    
    if !status.success() {
        return Err("åˆæˆè§†é¢‘å¤±è´¥".into());
    }
    
    // 5. åˆå¹¶åŸéŸ³è½¨
    window.emit("upscale_progress", "æ­£åœ¨åˆå¹¶éŸ³è½¨...").ok();
    let status = Command::new("ffmpeg")
        .args([
            "-i", &temp_video.to_string_lossy(),
            "-i", &input,
            "-c:v", "copy",
            "-c:a", "aac",
            "-map", "0:v:0",
            "-map", "1:a:0?",
            "-y",
            &output
        ])
        .status()
        .map_err(|e| e.to_string())?;
    
    // æ¸…ç†ä¸´æ—¶æ–‡ä»¶
    let _ = fs::remove_dir_all(&temp_dir);
    
    if status.success() {
        Ok(output)
    } else {
        Err("åˆå¹¶éŸ³è½¨å¤±è´¥".into())
    }
}

fn get_video_fps(path: &str) -> Result<f64, String> {
    let output = Command::new("ffprobe")
        .args([
            "-v", "error",
            "-select_streams", "v:0",
            "-show_entries", "stream=r_frame_rate",
            "-of", "default=noprint_wrappers=1:nokey=1",
            path
        ])
        .output()
        .map_err(|e| e.to_string())?;
    
    let fps_str = String::from_utf8_lossy(&output.stdout);
    // æ ¼å¼å¯èƒ½æ˜¯ "30/1" æˆ– "29.97"
    let fps_str = fps_str.trim();
    if fps_str.contains('/') {
        let parts: Vec<&str> = fps_str.split('/').collect();
        let num: f64 = parts[0].parse().unwrap_or(30.0);
        let den: f64 = parts[1].parse().unwrap_or(1.0);
        Ok(num / den)
    } else {
        fps_str.parse().map_err(|e: std::num::ParseFloatError| e.to_string())
    }
}

#[cfg(target_os = "windows")]
fn get_realesrgan_path() -> String {
    "resources/realesrgan-ncnn-vulkan.exe".into()
}

#[cfg(not(target_os = "windows"))]
fn get_realesrgan_path() -> String {
    "resources/realesrgan-ncnn-vulkan".into()
}
```

#### æ–¹æ¡ˆ Bï¼šè°ƒç”¨äº‘ç«¯ APIï¼ˆæ¨èæ™®é€šç”¨æˆ·ï¼‰

```rust
// è°ƒç”¨ç¬¬ä¸‰æ–¹ APIï¼Œå¦‚ï¼š
// - è…¾è®¯äº‘è§†é¢‘å¤„ç†
// - é˜¿é‡Œäº‘è§†é¢‘å¢å¼º
// - Topaz Video AI API

#[tauri::command]
pub async fn upscale_video_cloud(
    input: String,
    api_key: String,
) -> Result<String, String> {
    // 1. ä¸Šä¼ è§†é¢‘åˆ°äº‘ç«¯
    // 2. è°ƒç”¨ API å¤„ç†
    // 3. è½®è¯¢ç­‰å¾…å®Œæˆ
    // 4. ä¸‹è½½å¤„ç†åçš„è§†é¢‘
    todo!()
}
```

**å‰ç«¯ç•Œé¢**ï¼š
```typescript
// src/pages/VideoUpscale.tsx
import { useState, useEffect } from 'react';
import { invoke } from '@tauri-apps/api/tauri';
import { open, save } from '@tauri-apps/api/dialog';
import { listen } from '@tauri-apps/api/event';

export default function VideoUpscale() {
  const [videoPath, setVideoPath] = useState('');
  const [scale, setScale] = useState(2);
  const [processing, setProcessing] = useState(false);
  const [progress, setProgress] = useState('');

  useEffect(() => {
    const unlisten = listen('upscale_progress', (event) => {
      setProgress(event.payload as string);
    });
    return () => { unlisten.then(fn => fn()); };
  }, []);

  async function selectVideo() {
    const file = await open({
      filters: [{ name: 'è§†é¢‘æ–‡ä»¶', extensions: ['mp4', 'mov', 'avi', 'mkv'] }]
    });
    if (file && typeof file === 'string') {
      setVideoPath(file);
    }
  }

  async function startUpscale() {
    const outputPath = await save({
      defaultPath: 'upscaled.mp4',
      filters: [{ name: 'è§†é¢‘æ–‡ä»¶', extensions: ['mp4'] }]
    });
    if (!outputPath) return;

    setProcessing(true);
    setProgress('å‡†å¤‡ä¸­...');
    try {
      await invoke('upscale_video', {
        input: videoPath,
        output: outputPath,
        scale,
      });
      alert('å¤„ç†å®Œæˆï¼');
    } catch (e) {
      alert('å¤„ç†å¤±è´¥: ' + e);
    } finally {
      setProcessing(false);
      setProgress('');
    }
  }

  return (
    <div className="upscale-page">
      <h2>è§†é¢‘æ¸…æ™°åº¦è¿˜åŸ</h2>
      
      <button onClick={selectVideo}>é€‰æ‹©è§†é¢‘</button>
      {videoPath && <p>å·²é€‰æ‹©: {videoPath}</p>}
      
      <div className="scale-options">
        <label>
          <input type="radio" value={2} checked={scale === 2} onChange={() => setScale(2)} />
          2x æ”¾å¤§
        </label>
        <label>
          <input type="radio" value={4} checked={scale === 4} onChange={() => setScale(4)} />
          4x æ”¾å¤§ï¼ˆæ›´æ¸…æ™°ï¼Œæ›´æ…¢ï¼‰
        </label>
      </div>
      
      <button onClick={startUpscale} disabled={!videoPath || processing}>
        {processing ? progress : 'å¼€å§‹å¤„ç†'}
      </button>
      
      <p className="tip">
        æç¤ºï¼šè§†é¢‘è¶…åˆ†å¤„ç†è¾ƒæ…¢ï¼Œ1åˆ†é’Ÿè§†é¢‘å¯èƒ½éœ€è¦ 10-30 åˆ†é’Ÿå¤„ç†æ—¶é—´
      </p>
    </div>
  );
}
```

## äº”ã€UI è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ“ æ–‡ä»¶å·¥å…·ç®±                              â”€  â–¡  Ã—    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚ğŸ“Š ç»Ÿè®¡  â”‚ â”‚ğŸ” å»é‡  â”‚ â”‚âœ‚ï¸ æˆªå–  â”‚ â”‚âœ¨ è¶…åˆ†  â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  ã€æ–‡ä»¶å»é‡é¡µé¢ç¤ºä¾‹ã€‘                                    â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  ğŸ“ é€‰æ‹©æ–‡ä»¶å¤¹    ğŸ”„ æ™ºèƒ½é€‰æ‹©    ï¿½ï¸  åˆ é™¤é€‰ä¸­(3)  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                         â”‚
â”‚  å‘ç° 5 ç»„é‡å¤æ–‡ä»¶ï¼Œå…± 12 ä¸ªæ–‡ä»¶ï¼Œå¯é‡Šæ”¾ 156 MB         â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ ç¬¬ 1 ç»„ | 2.3 MB | 3 ä¸ªæ–‡ä»¶                      â”‚   â”‚
â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚   â”‚
â”‚  â”‚ â”‚ â˜ photo_001.jpg                             â”‚ â”‚   â”‚
â”‚  â”‚ â”‚   /Users/xxx/Downloads/photo_001.jpg        â”‚ â”‚   â”‚
â”‚  â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚   â”‚
â”‚  â”‚ â”‚ â˜‘ photo_001(1).jpg                          â”‚ â”‚   â”‚
â”‚  â”‚ â”‚   /Users/xxx/Desktop/photo_001(1).jpg       â”‚ â”‚   â”‚
â”‚  â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚   â”‚
â”‚  â”‚ â”‚ â˜‘ å‰¯æœ¬_photo.jpg                            â”‚ â”‚   â”‚
â”‚  â”‚ â”‚   /Users/xxx/Documents/å‰¯æœ¬_photo.jpg       â”‚ â”‚   â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ ç¬¬ 2 ç»„ | 15.6 MB | 2 ä¸ªæ–‡ä»¶                     â”‚   â”‚
â”‚  â”‚ ...                                             â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## å…­ã€é¡¹ç›®ç»“æ„

```
file-toolkit/
â”œâ”€â”€ src/                          # å‰ç«¯ä»£ç 
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ DropZone.tsx          # æ‹–æ‹½åŒºåŸŸ
â”‚   â”‚   â”œâ”€â”€ StatsTable.tsx        # ç»Ÿè®¡è¡¨æ ¼
â”‚   â”‚   â”œâ”€â”€ DuplicateList.tsx     # é‡å¤æ–‡ä»¶åˆ—è¡¨
â”‚   â”‚   â””â”€â”€ VideoEditor.tsx       # è§†é¢‘ç¼–è¾‘å™¨
â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â”œâ”€â”€ FileStats.tsx         # æ–‡ä»¶ç»Ÿè®¡é¡µ
â”‚   â”‚   â”œâ”€â”€ Dedup.tsx             # å»é‡é¡µ
â”‚   â”‚   â”œâ”€â”€ Rename.tsx            # é‡å‘½åé¡µ
â”‚   â”‚   â””â”€â”€ Video.tsx             # è§†é¢‘å¤„ç†é¡µ
â”‚   â”œâ”€â”€ App.tsx
â”‚   â””â”€â”€ main.tsx
â”œâ”€â”€ src-tauri/                    # Rust åç«¯
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ commands/
â”‚   â”‚   â”‚   â”œâ”€â”€ file_stats.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ dedup.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ rename.rs
â”‚   â”‚   â”‚   â””â”€â”€ video.rs
â”‚   â”‚   â”œâ”€â”€ lib.rs
â”‚   â”‚   â””â”€â”€ main.rs
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â””â”€â”€ tauri.conf.json
â”œâ”€â”€ package.json
â””â”€â”€ README.md
```

## ä¸ƒã€FFmpeg æ‰“åŒ…ç­–ç•¥

### æ–¹æ¡ˆ Aï¼šå†…ç½® FFmpegï¼ˆæ¨èï¼‰
- æ‰“åŒ…æ—¶å°† FFmpeg äºŒè¿›åˆ¶æ–‡ä»¶æ”¾å…¥ resources
- ä¼˜ç‚¹ï¼šå¼€ç®±å³ç”¨
- ç¼ºç‚¹ï¼šåŒ…ä½“å¢å¤§ ~80MB

### æ–¹æ¡ˆ Bï¼šç³»ç»Ÿ FFmpeg
- æ£€æµ‹ç³»ç»Ÿæ˜¯å¦å®‰è£… FFmpeg
- æœªå®‰è£…åˆ™å¼•å¯¼ç”¨æˆ·å®‰è£…
- ä¼˜ç‚¹ï¼šåŒ…ä½“å°
- ç¼ºç‚¹ï¼šç”¨æˆ·ä½“éªŒå·®

```rust
// æ£€æµ‹ FFmpeg
fn check_ffmpeg() -> bool {
    Command::new("ffmpeg").arg("-version").output().is_ok()
}
```

## å…«ã€å¼€å‘è®¡åˆ’

| é˜¶æ®µ | åŠŸèƒ½ | æ—¶é—´ |
|------|------|------|
| P0.1 | é¡¹ç›®æ­å»º + æ–‡ä»¶ç»Ÿè®¡ï¼ˆé€’å½’éå†ï¼‰ | 2å¤© |
| P0.2 | æ–‡ä»¶å»é‡ï¼ˆMD5 + ç”¨æˆ·ç¡®è®¤åˆ é™¤ï¼‰ | 3å¤© |
| P1.1 | è§†é¢‘æˆªå–ï¼ˆæ—¶é—´æ®µé€‰æ‹©ï¼‰ | 2å¤© |
| P1.2 | è§†é¢‘æ¸…æ™°åº¦è¿˜åŸï¼ˆAI è¶…åˆ†ï¼‰ | 4å¤© |
| P2 | UI ä¼˜åŒ– + æµ‹è¯• + æ‰“åŒ…å‘å¸ƒ | 3å¤© |

**æ€»è®¡ï¼šçº¦ 14 å¤©**

## ä¹ã€æ³¨æ„äº‹é¡¹

### æ–‡ä»¶å»é‡å®‰å…¨æ€§
- åˆ é™¤å‰å¿…é¡»ç”¨æˆ·ç¡®è®¤
- æä¾›"æ™ºèƒ½é€‰æ‹©"ä½†ä¸è‡ªåŠ¨åˆ é™¤
- è€ƒè™‘åŠ å…¥"ç§»åŠ¨åˆ°å›æ”¶ç«™"è€Œéç›´æ¥åˆ é™¤

### è§†é¢‘è¶…åˆ†æ€§èƒ½
- æœ¬åœ°å¤„ç†éœ€è¦ GPUï¼Œå¦åˆ™å¾ˆæ…¢
- å»ºè®®æä¾›äº‘ç«¯ API é€‰é¡¹
- æ˜¾ç¤ºé¢„ä¼°å¤„ç†æ—¶é—´

### è·¨å¹³å°å…¼å®¹
- FFmpeg éœ€è¦åˆ†åˆ«æ‰“åŒ… Win/Mac ç‰ˆæœ¬
- Real-ESRGAN åŒæ ·éœ€è¦å¤šå¹³å°äºŒè¿›åˆ¶
- æ–‡ä»¶è·¯å¾„å¤„ç†æ³¨æ„ `/` å’Œ `\` å·®å¼‚

## åã€åç»­æ‰©å±•

- [ ] æ‰¹é‡æ°´å°æ·»åŠ 
- [ ] å›¾ç‰‡ EXIF ä¿¡æ¯æŸ¥çœ‹/ç¼–è¾‘
- [ ] æ–‡ä»¶åŠ å¯†/è§£å¯†
- [ ] äº‘å­˜å‚¨åŒæ­¥ï¼ˆOSS/S3ï¼‰
- [ ] æ’ä»¶ç³»ç»Ÿï¼ˆæ”¯æŒè‡ªå®šä¹‰å¤„ç†è„šæœ¬ï¼‰
