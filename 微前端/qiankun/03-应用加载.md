# Qiankun 微前端源码解析：应用加载

> 本文深入分析 Qiankun 3.0 的 HTML Entry 加载机制，理解 @qiankunjs/loader 的流式加载实现。

## Loader 架构

```
┌─────────────────────────────────────────────────────────────────┐
│                      @qiankunjs/loader                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │                     loadEntry                            │   │
│   │                                                          │   │
│   │   fetch(entry) ──▶ TextDecoderStream ──▶ TagTransform   │   │
│   │                                              │            │   │
│   │                                              ▼            │   │
│   │                                      WritableDOMStream   │   │
│   │                                              │            │   │
│   │                                              ▼            │   │
│   │                                         container        │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## loadEntry 核心流程

```typescript
// packages/loader/src/index.ts
export async function loadEntry<T>(
  entry: Entry | { url: string; res: Response },
  container: HTMLElement,
  opts: LoaderOpts,
): Promise<T | void> {
  const { fetch, streamTransformer, sandbox, nodeTransformer } = opts;

  const entryUrl = typeof entry === 'string' ? entry : entry.url;
  const res = typeof entry === 'string' ? await fetch(entry) : entry.res;

  if (res.body) {
    let foundEntryScript = false;
    const entryScriptLoadedDeferred = new Deferred<T | void>();

    // defer 脚本队列
    const deferQueue: Array<Deferred<void>> = [];
    const { deferred: entryHTMLLoadedDeferred, queue: queueEntryHTMLDeferred } = prepareDeferredQueue(deferQueue);
    queueEntryHTMLDeferred();

    // 1. 解码响应流
    let readableStream = res.body.pipeThrough(new TextDecoderStream());

    // 2. 用户自定义转换
    if (streamTransformer) {
      readableStream = readableStream.pipeThrough(streamTransformer());
    }

    // 3. 标签转换（head → qiankun-head）
    // 4. 写入 DOM
    void readableStream
      .pipeThrough(createTagTransformStream([
        { tag: '<head>', alt: `<${qiankunHeadTagName}>` },
        { tag: '</head>', alt: `</${qiankunHeadTagName}>` },
      ], {}))
      .pipeTo(new WritableDOMStream(container, null, (clone) => {
        // 节点转换
        const transformedNode = nodeTransformer ? nodeTransformer(clone, transformerOpts) : clone;
        
        // 处理 entry script
        if (isEntryScript(script)) {
          foundEntryScript = true;
          script.onload = () => {
            entryScriptLoadedDeferred.resolve(sandbox.globalThis[sandbox.latestSetProp]);
          };
        }

        return transformedNode;
      }))
      .then(() => {
        if (!foundEntryScript) {
          onEntryLoaded();
        }
        entryHTMLLoadedDeferred.resolve();
      });

    return entryScriptLoadedDeferred.promise;
  }
}
```

## 流式加载流程图

```
┌─────────────────────────────────────────────────────────────────┐
│                      流式加载流程                                │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
              ┌───────────────────────────────┐
              │     1. fetch(entry)           │
              │   获取 HTML 响应流             │
              └───────────────────────────────┘
                              │
                              ▼
              ┌───────────────────────────────┐
              │     2. TextDecoderStream      │
              │   字节流 → 文本流              │
              └───────────────────────────────┘
                              │
                              ▼
              ┌───────────────────────────────┐
              │     3. TagTransformStream     │
              │   <head> → <qiankun-head>     │
              └───────────────────────────────┘
                              │
                              ▼
              ┌───────────────────────────────┐
              │     4. WritableDOMStream      │
              │   流式写入 DOM                 │
              │   - 解析 HTML 片段            │
              │   - 转换节点（沙箱包装）       │
              │   - 插入容器                  │
              └───────────────────────────────┘
                              │
                              ▼
              ┌───────────────────────────────┐
              │     5. 等待 entry script      │
              │   获取子应用生命周期           │
              └───────────────────────────────┘
```

## TagTransformStream

标签转换流，将 `<head>` 替换为 `<qiankun-head>`：

```typescript
// packages/loader/src/TagTransformStream.ts
export function createTagTransformStream(
  replacements: Array<{ tag: string; alt: string }>,
  opts: { head?: boolean },
): TransformStream<string, string> {
  let buffer = '';

  return new TransformStream({
    transform(chunk, controller) {
      buffer += chunk;

      // 替换标签
      for (const { tag, alt } of replacements) {
        buffer = buffer.replace(new RegExp(tag, 'gi'), alt);
      }

      // 输出处理后的内容
      controller.enqueue(buffer);
      buffer = '';
    },

    flush(controller) {
      if (buffer) {
        controller.enqueue(buffer);
      }
    },
  });
}
```

### 为什么要替换 head 标签？

```html
<!-- 原始 HTML -->
<html>
  <head>
    <link rel="stylesheet" href="app.css">
    <script src="app.js"></script>
  </head>
  <body>
    <div id="app"></div>
  </body>
</html>

<!-- 转换后 -->
<html>
  <qiankun-head>
    <link rel="stylesheet" href="app.css">
    <script src="app.js"></script>
  </qiankun-head>
  <body>
    <div id="app"></div>
  </body>
</html>
```

原因：
1. 避免子应用的 `<head>` 内容污染主应用的 `<head>`
2. 自定义元素不会被浏览器特殊处理
3. 便于样式和脚本的隔离管理

## WritableDOMStream

流式写入 DOM 的核心实现（基于 writable-dom）：

```typescript
// packages/loader/src/writable-dom/index.ts
export default class WritableDOMStream extends WritableStream<string> {
  constructor(
    container: HTMLElement,
    previousSibling: Node | null,
    nodeTransformer?: (node: Node) => Node,
  ) {
    const doc = container.ownerDocument!;
    let pendingText = '';

    super({
      write(chunk) {
        pendingText += chunk;

        // 创建临时容器解析 HTML
        const template = doc.createElement('template');
        template.innerHTML = pendingText;

        // 遍历解析出的节点
        const fragment = template.content;
        while (fragment.firstChild) {
          let node = fragment.firstChild;

          // 应用节点转换
          if (nodeTransformer) {
            node = nodeTransformer(node);
          }

          // 插入容器
          container.appendChild(node);
        }

        pendingText = '';
      },

      close() {
        // 处理剩余内容
        if (pendingText) {
          const template = doc.createElement('template');
          template.innerHTML = pendingText;
          container.appendChild(template.content);
        }
      },
    });
  }
}
```

## 脚本处理

### 脚本类型判断

```typescript
// 外部脚本
const isExternalScript = (script: HTMLScriptElement): boolean => {
  return script.tagName === 'SCRIPT' && !!(script.src || script.dataset.src);
};

// 入口脚本（带 entry 属性）
const isEntryScript = (script: HTMLScriptElement): boolean => {
  return isExternalScript(script) && script.hasAttribute('entry');
};

// defer 脚本
const isDeferScript = (script: HTMLScriptElement): boolean => {
  return isExternalScript(script) && script.hasAttribute('defer');
};
```

### 脚本沙箱包装

通过 `nodeTransformer` 对脚本进行沙箱包装：

```typescript
// packages/qiankun/src/core/loadApp.ts
const defaultNodeTransformer: AppConfiguration['nodeTransformer'] = (node, opts) => {
  const moduleResolver = (url: string) => defaultModuleResolver(url, microAppDOMContainer, document.head);
  return transpileAssets(node, entry, { ...opts, moduleResolver });
};
```

```typescript
// @qiankunjs/shared
export function transpileAssets(
  node: Node,
  entry: string,
  opts: AssetsTranspilerOpts,
): Node {
  if (node instanceof HTMLScriptElement) {
    return transpileScript(node, entry, opts);
  }
  if (node instanceof HTMLLinkElement) {
    return transpileLink(node, entry, opts);
  }
  return node;
}

function transpileScript(
  script: HTMLScriptElement,
  entry: string,
  opts: ScriptTranspilerOpts,
): HTMLScriptElement {
  const { sandbox } = opts;

  if (script.src) {
    // 外部脚本：保持原样，但需要在沙箱环境执行
    // 通过 sandbox.makeEvaluateFactory 包装
  } else {
    // 内联脚本：包装代码
    const code = script.textContent || '';
    const wrappedCode = sandbox.makeEvaluateFactory(code, entry);
    script.textContent = wrappedCode;
  }

  return script;
}
```

### 内联脚本包装示例

```javascript
// 原始代码
window.myApp = {
  bootstrap: () => {},
  mount: () => {},
  unmount: () => {},
};

// 包装后
;(function(){
  with(this){
    const {window,document,console,...} = this;
    window.myApp = {
      bootstrap: () => {},
      mount: () => {},
      unmount: () => {},
    };
  }
}).bind(window.__compartment_globalThis__0__)();
```

## defer 脚本处理

defer 脚本需要等待 HTML 解析完成后按顺序执行：

```typescript
// defer 脚本队列
const deferQueue: Array<Deferred<void>> = [];

// 处理 defer 脚本
if (isDeferScript(script)) {
  const { deferred, prevDeferred, queue } = prepareDeferredQueue(deferQueue);
  
  transformerOpts = {
    ...transformerOpts,
    scriptTranspiledDeferred: deferred,
    prevScriptTranspiledDeferred: prevDeferred,
  };
  
  queueDeferScript = queue;
}
```

```
┌─────────────────────────────────────────────────────────────────┐
│                    defer 脚本执行顺序                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   HTML 解析 ──▶ defer1 加载 ──▶ defer2 加载 ──▶ defer3 加载     │
│                     │              │              │              │
│                     ▼              ▼              ▼              │
│   HTML 完成 ──▶ defer1 执行 ──▶ defer2 执行 ──▶ defer3 执行     │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## Entry Script 处理

入口脚本是获取子应用生命周期的关键：

```typescript
if (isEntryScript(script)) {
  if (foundEntryScript) {
    throw new QiankunError('You should not include more than 1 entry scripts');
  }

  foundEntryScript = true;

  const onScriptComplete = (prevListener, event) => {
    script.onload = script.onerror = null;

    if (!entryScriptLoadedDeferred.isSettled()) {
      if (event.type === 'load') {
        // 从沙箱获取最后设置的属性（即生命周期对象）
        entryScriptLoadedDeferred.resolve(
          sandbox.globalThis[sandbox.latestSetProp]
        );
      } else {
        entryScriptLoadedDeferred.reject(new QiankunError('Entry script load failed'));
      }
    }

    prevListener?.call(script, event);
  };

  script.onload = onScriptComplete.bind(null, script.onload);
  script.onerror = onScriptComplete.bind(null, script.onerror);
}
```

## Fetch 增强

Qiankun 对 fetch 进行了多层增强：

```typescript
// packages/qiankun/src/core/loadApp.ts
const enhancedFetch = makeFetchCacheable(
  makeFetchRetryable(
    makeFetchThrowable(fetch)
  )
);
```

```typescript
// @qiankunjs/shared

// 1. 错误处理
export function makeFetchThrowable(fetch: Fetch): Fetch {
  return async (url, opts) => {
    const res = await fetch(url, opts);
    if (!res.ok) {
      throw new QiankunError(`Fetch ${url} failed with status ${res.status}`);
    }
    return res;
  };
}

// 2. 重试机制
export function makeFetchRetryable(fetch: Fetch, retries = 3): Fetch {
  return async (url, opts) => {
    let lastError: Error;
    for (let i = 0; i < retries; i++) {
      try {
        return await fetch(url, opts);
      } catch (e) {
        lastError = e;
      }
    }
    throw lastError;
  };
}

// 3. 缓存机制
export function makeFetchCacheable(fetch: Fetch): Fetch {
  const cache = new Map<string, Promise<Response>>();
  
  return (url, opts) => {
    const key = typeof url === 'string' ? url : url.toString();
    
    if (!cache.has(key)) {
      cache.set(key, fetch(url, opts).then((res) => res.clone()));
    }
    
    return cache.get(key)!.then((res) => res.clone());
  };
}
```

## 小结

Qiankun 3.0 Loader 的核心设计：

1. **流式加载**：使用 Streams API 实现边下载边解析
2. **标签转换**：将 head 替换为自定义标签避免污染
3. **脚本沙箱**：通过 nodeTransformer 包装脚本代码
4. **defer 队列**：保证 defer 脚本按顺序执行
5. **Fetch 增强**：缓存、重试、错误处理

---

> 下一篇：生命周期
