# Qiankun 微前端源码解析：通信机制

> 本文分析 Qiankun 中主子应用的通信方式，包括 props 传递和全局状态管理。

## 通信方式概览

```
┌─────────────────────────────────────────────────────────────────┐
│                      通信方式                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   1. Props 传递                                                  │
│      主应用 ──props──▶ 子应用                                    │
│                                                                  │
│   2. 全局状态（initGlobalState）                                 │
│      主应用 ◀──state──▶ 子应用                                   │
│                                                                  │
│   3. 自定义事件                                                  │
│      主应用 ◀──CustomEvent──▶ 子应用                             │
│                                                                  │
│   4. 共享依赖                                                    │
│      主应用 ──shared libs──▶ 子应用                              │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## Props 传递

### 注册时传递

```typescript
// 主应用
import { registerMicroApps, start } from 'qiankun';

registerMicroApps([
  {
    name: 'react-app',
    entry: '//localhost:7100',
    container: '#container',
    activeRule: '/react',
    props: {
      // 传递给子应用的数据
      user: { name: 'admin', role: 'admin' },
      token: 'xxx',
      // 传递方法
      onLogout: () => {
        console.log('logout');
      },
      // 传递共享服务
      utils: {
        request: axios,
        storage: localStorage,
      },
    },
  },
]);

start();
```

### 子应用接收

```typescript
// 子应用
export async function mount(props) {
  const { container, user, token, onLogout, utils } = props;
  
  console.log('user:', user);
  console.log('token:', token);
  
  // 使用传递的方法
  // onLogout();
  
  // 使用共享服务
  // utils.request.get('/api/data');
  
  ReactDOM.render(<App {...props} />, container.querySelector('#root'));
}
```

### Props 传递流程

```typescript
// packages/qiankun/src/apis/registerMicroApps.ts
registerApplication({
  name,
  app: async () => {
    const { mount, ...otherMicroAppConfigs } = (
      await loadApp({ name, entry, container, props }, frameworkConfiguration, lifeCycles)
    )(container);

    return {
      mount: [
        ...toArray(mount),
      ],
      ...otherMicroAppConfigs,
    };
  },
  activeWhen: activeRule,
  customProps: props,  // 传递给 single-spa
});
```

```typescript
// packages/qiankun/src/core/loadApp.ts
mount: [
  // ...
  async (props) => mount({ ...props, container: mountContainer }),
  // ...
],
```

## 全局状态管理

Qiankun 2.x 提供了 `initGlobalState` API（3.0 中已移除，推荐使用其他状态管理方案）：

### 2.x 版本实现参考

```typescript
// 主应用
import { initGlobalState, MicroAppStateActions } from 'qiankun';

const state = {
  user: { name: 'admin' },
  theme: 'light',
};

const actions: MicroAppStateActions = initGlobalState(state);

// 监听变化
actions.onGlobalStateChange((state, prev) => {
  console.log('主应用监听到变化:', state, prev);
});

// 修改状态
actions.setGlobalState({ theme: 'dark' });

// 取消监听
// actions.offGlobalStateChange();
```

```typescript
// 子应用
export function mount(props) {
  const { onGlobalStateChange, setGlobalState } = props;
  
  // 监听变化
  onGlobalStateChange((state, prev) => {
    console.log('子应用监听到变化:', state, prev);
  }, true);  // true 表示立即触发一次
  
  // 修改状态
  setGlobalState({ user: { name: 'guest' } });
}
```

### 简易实现

```typescript
// 全局状态管理器
function createGlobalState<T extends object>(initialState: T) {
  let globalState = { ...initialState };
  const listeners = new Set<(state: T, prev: T) => void>();

  return {
    getGlobalState(): T {
      return globalState;
    },

    setGlobalState(state: Partial<T>): void {
      const prevState = { ...globalState };
      globalState = { ...globalState, ...state };
      
      // 通知所有监听者
      listeners.forEach((listener) => {
        listener(globalState, prevState);
      });
    },

    onGlobalStateChange(
      listener: (state: T, prev: T) => void,
      fireImmediately = false
    ): () => void {
      listeners.add(listener);
      
      if (fireImmediately) {
        listener(globalState, globalState);
      }
      
      // 返回取消监听函数
      return () => {
        listeners.delete(listener);
      };
    },
  };
}

// 使用
const globalState = createGlobalState({ user: null, theme: 'light' });
export const { getGlobalState, setGlobalState, onGlobalStateChange } = globalState;
```

## 自定义事件通信

```typescript
// 事件总线
class EventBus {
  private events = new Map<string, Set<Function>>();

  on(event: string, callback: Function): () => void {
    if (!this.events.has(event)) {
      this.events.set(event, new Set());
    }
    this.events.get(event)!.add(callback);
    
    return () => this.off(event, callback);
  }

  off(event: string, callback: Function): void {
    this.events.get(event)?.delete(callback);
  }

  emit(event: string, ...args: unknown[]): void {
    this.events.get(event)?.forEach((callback) => {
      callback(...args);
    });
  }
}

// 全局事件总线
export const eventBus = new EventBus();
```

```typescript
// 主应用
import { eventBus } from './eventBus';

eventBus.on('micro-app:message', (data) => {
  console.log('收到子应用消息:', data);
});

// 发送消息给子应用
eventBus.emit('main-app:message', { type: 'update', payload: {} });
```

```typescript
// 子应用
export function mount(props) {
  const { eventBus } = props;
  
  eventBus.on('main-app:message', (data) => {
    console.log('收到主应用消息:', data);
  });
  
  // 发送消息给主应用
  eventBus.emit('micro-app:message', { type: 'ready' });
}
```

## 使用 CustomEvent

```typescript
// 主应用
window.addEventListener('micro-app-event', (e: CustomEvent) => {
  console.log('收到子应用事件:', e.detail);
});

// 发送事件给子应用
window.dispatchEvent(new CustomEvent('main-app-event', {
  detail: { type: 'update', data: {} },
}));
```

```typescript
// 子应用
export function mount(props) {
  window.addEventListener('main-app-event', (e: CustomEvent) => {
    console.log('收到主应用事件:', e.detail);
  });
  
  // 发送事件给主应用
  window.dispatchEvent(new CustomEvent('micro-app-event', {
    detail: { type: 'ready' },
  }));
}
```

## 共享依赖

### Webpack 5 Module Federation

```javascript
// 主应用 webpack.config.js
const { ModuleFederationPlugin } = require('webpack').container;

module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'main',
      shared: {
        react: { singleton: true },
        'react-dom': { singleton: true },
      },
    }),
  ],
};
```

```javascript
// 子应用 webpack.config.js
module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'micro_app',
      shared: {
        react: { singleton: true },
        'react-dom': { singleton: true },
      },
    }),
  ],
};
```

### 通过 Props 共享

```typescript
// 主应用
import React from 'react';
import ReactDOM from 'react-dom';
import axios from 'axios';

registerMicroApps([
  {
    name: 'react-app',
    entry: '//localhost:7100',
    container: '#container',
    activeRule: '/react',
    props: {
      // 共享依赖
      shared: {
        React,
        ReactDOM,
        axios,
      },
    },
  },
]);
```

```typescript
// 子应用
let React, ReactDOM;

export async function bootstrap(props) {
  const { shared } = props;
  React = shared.React;
  ReactDOM = shared.ReactDOM;
}
```

## 通信架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                        主应用                                    │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                    Global State                            │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │  │
│  │  │    user     │  │    theme    │  │   config    │        │  │
│  │  └─────────────┘  └─────────────┘  └─────────────┘        │  │
│  └───────────────────────────────────────────────────────────┘  │
│                              │                                   │
│              ┌───────────────┼───────────────┐                  │
│              │               │               │                  │
│              ▼               ▼               ▼                  │
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐   │
│  │    子应用 A      │ │    子应用 B      │ │    子应用 C      │   │
│  │                 │ │                 │ │                 │   │
│  │  props: {       │ │  props: {       │ │  props: {       │   │
│  │    user,        │ │    user,        │ │    user,        │   │
│  │    setGlobal,   │ │    setGlobal,   │ │    setGlobal,   │   │
│  │    eventBus,    │ │    eventBus,    │ │    eventBus,    │   │
│  │  }              │ │  }              │ │  }              │   │
│  └─────────────────┘ └─────────────────┘ └─────────────────┘   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## 最佳实践

### 1. 统一通信接口

```typescript
// shared/communication.ts
export interface MicroAppProps {
  // 基础信息
  name: string;
  container: HTMLElement;
  
  // 用户信息
  user: User | null;
  token: string;
  
  // 状态管理
  getGlobalState: () => GlobalState;
  setGlobalState: (state: Partial<GlobalState>) => void;
  onGlobalStateChange: (listener: StateListener) => () => void;
  
  // 事件通信
  eventBus: EventBus;
  
  // 共享服务
  services: {
    request: AxiosInstance;
    storage: Storage;
    router: Router;
  };
}
```

### 2. 类型安全

```typescript
// 定义全局状态类型
interface GlobalState {
  user: User | null;
  theme: 'light' | 'dark';
  locale: string;
}

// 定义事件类型
type EventMap = {
  'user:login': { user: User };
  'user:logout': void;
  'theme:change': { theme: 'light' | 'dark' };
};

// 类型安全的事件总线
class TypedEventBus<T extends Record<string, unknown>> {
  emit<K extends keyof T>(event: K, data: T[K]): void;
  on<K extends keyof T>(event: K, callback: (data: T[K]) => void): () => void;
}
```

### 3. 避免循环依赖

```typescript
// ❌ 错误：子应用直接修改主应用状态
export function mount(props) {
  props.mainAppState.user = newUser;  // 直接修改
}

// ✅ 正确：通过方法修改
export function mount(props) {
  props.setGlobalState({ user: newUser });  // 通过方法
}
```

## 小结

Qiankun 通信机制的核心要点：

1. **Props 传递**：最直接的通信方式，适合单向数据流
2. **全局状态**：适合需要双向同步的场景
3. **事件通信**：适合松耦合的消息传递
4. **共享依赖**：减少重复加载，提升性能

---

> 下一篇：路由劫持
