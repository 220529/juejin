# Qiankun 微前端源码解析：路由劫持

> 本文分析 Qiankun 基于 single-spa 的路由劫持机制，理解子应用如何根据路由自动加载和卸载。

## 路由机制概览

```
┌─────────────────────────────────────────────────────────────────┐
│                      路由劫持机制                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   URL 变化                                                       │
│      │                                                           │
│      ▼                                                           │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │              single-spa 路由监听                         │   │
│   │   - hashchange                                          │   │
│   │   - popstate                                            │   │
│   │   - pushState / replaceState 劫持                       │   │
│   └─────────────────────────────────────────────────────────┘   │
│      │                                                           │
│      ▼                                                           │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │              匹配 activeRule                             │   │
│   │   - 字符串匹配                                           │   │
│   │   - 函数匹配                                             │   │
│   │   - 正则匹配                                             │   │
│   └─────────────────────────────────────────────────────────┘   │
│      │                                                           │
│      ▼                                                           │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │              加载/卸载子应用                              │   │
│   │   - mount 匹配的应用                                     │   │
│   │   - unmount 不匹配的应用                                 │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## single-spa 路由劫持

### History API 劫持

```typescript
// single-spa 源码简化
const originalPushState = window.history.pushState;
const originalReplaceState = window.history.replaceState;

window.history.pushState = function(state, title, url) {
  const result = originalPushState.apply(this, arguments);
  // 触发路由变化检查
  reroute();
  return result;
};

window.history.replaceState = function(state, title, url) {
  const result = originalReplaceState.apply(this, arguments);
  reroute();
  return result;
};

// 监听 popstate 事件
window.addEventListener('popstate', () => {
  reroute();
});

// 监听 hashchange 事件
window.addEventListener('hashchange', () => {
  reroute();
});
```

### reroute 核心逻辑

```typescript
function reroute() {
  const { appsToLoad, appsToMount, appsToUnmount } = getAppChanges();

  // 卸载不再匹配的应用
  await Promise.all(appsToUnmount.map(unmountApp));

  // 加载新匹配的应用
  await Promise.all(appsToLoad.map(loadApp));

  // 挂载匹配的应用
  await Promise.all(appsToMount.map(mountApp));
}

function getAppChanges() {
  const appsToLoad = [];
  const appsToMount = [];
  const appsToUnmount = [];

  apps.forEach((app) => {
    const shouldBeActive = app.activeWhen(window.location);
    
    switch (app.status) {
      case 'NOT_LOADED':
        if (shouldBeActive) {
          appsToLoad.push(app);
        }
        break;
      case 'NOT_MOUNTED':
        if (shouldBeActive) {
          appsToMount.push(app);
        }
        break;
      case 'MOUNTED':
        if (!shouldBeActive) {
          appsToUnmount.push(app);
        }
        break;
    }
  });

  return { appsToLoad, appsToMount, appsToUnmount };
}
```

## Qiankun 的 activeRule

### 注册应用

```typescript
// packages/qiankun/src/apis/registerMicroApps.ts
export function registerMicroApps<T extends ObjectType>(
  apps: Array<RegistrableApp<T>>, 
  lifeCycles?: LifeCycles<T>
) {
  unregisteredApps.forEach((app) => {
    const { name, activeRule, loader = noop, props, entry, container } = app;

    // 调用 single-spa 的 registerApplication
    registerApplication({
      name,
      app: async () => {
        // 加载应用逻辑
        const parcelConfig = await loadApp({ name, entry, container, props }, configuration, lifeCycles);
        return parcelConfig(container);
      },
      activeWhen: activeRule,  // 路由匹配规则
      customProps: props,
    });
  });
}
```

### activeRule 类型

```typescript
// 字符串
activeRule: '/react'

// 字符串数组
activeRule: ['/react', '/react-app']

// 函数
activeRule: (location) => location.pathname.startsWith('/react')

// 正则（需要转换为函数）
activeRule: (location) => /^\/react/.test(location.pathname)
```

### 路由匹配示例

```typescript
registerMicroApps([
  {
    name: 'react-app',
    entry: '//localhost:7100',
    container: '#container',
    // 字符串匹配
    activeRule: '/react',
  },
  {
    name: 'vue-app',
    entry: '//localhost:7200',
    container: '#container',
    // 函数匹配
    activeRule: (location) => {
      return location.pathname.startsWith('/vue') || 
             location.hash.startsWith('#/vue');
    },
  },
  {
    name: 'angular-app',
    entry: '//localhost:7300',
    container: '#container',
    // 多路径匹配
    activeRule: ['/angular', '/ng'],
  },
]);
```

## 路由同步

### 主应用路由

```typescript
// 主应用 - React Router
import { BrowserRouter, Routes, Route } from 'react-router-dom';

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        {/* 子应用容器 */}
        <Route path="/react/*" element={<div id="container" />} />
        <Route path="/vue/*" element={<div id="container" />} />
      </Routes>
    </BrowserRouter>
  );
}
```

### 子应用路由

```typescript
// 子应用 - React Router
import { BrowserRouter, Routes, Route } from 'react-router-dom';

function App() {
  return (
    // 设置 basename
    <BrowserRouter basename={window.__POWERED_BY_QIANKUN__ ? '/react' : '/'}>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/list" element={<List />} />
        <Route path="/detail/:id" element={<Detail />} />
      </Routes>
    </BrowserRouter>
  );
}
```

### 子应用 Vue Router

```typescript
// 子应用 - Vue Router
import { createRouter, createWebHistory } from 'vue-router';

const router = createRouter({
  history: createWebHistory(window.__POWERED_BY_QIANKUN__ ? '/vue' : '/'),
  routes: [
    { path: '/', component: Home },
    { path: '/list', component: List },
  ],
});
```

## History 监听补丁

Qiankun 沙箱对 History 监听进行了补丁：

```typescript
// packages/sandbox/src/patchers/historyListener.ts
export function patchHistoryListener(sandbox: Sandbox): Free {
  const { globalThis } = sandbox;
  const listeners: Array<PopStateEventListener> = [];

  const rawAddEventListener = globalThis.addEventListener;
  const rawRemoveEventListener = globalThis.removeEventListener;

  globalThis.addEventListener = function(
    type: string, 
    listener: EventListener, 
    options?: boolean | AddEventListenerOptions
  ) {
    if (type === 'popstate' || type === 'hashchange') {
      listeners.push(listener as PopStateEventListener);
    }
    return rawAddEventListener.call(this, type, listener, options);
  };

  globalThis.removeEventListener = function(
    type: string, 
    listener: EventListener, 
    options?: boolean | EventListenerOptions
  ) {
    if (type === 'popstate' || type === 'hashchange') {
      const index = listeners.indexOf(listener as PopStateEventListener);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    }
    return rawRemoveEventListener.call(this, type, listener, options);
  };

  return function free(): Rebuild {
    // 移除所有监听器
    listeners.forEach((listener) => {
      rawRemoveEventListener.call(globalThis, 'popstate', listener);
      rawRemoveEventListener.call(globalThis, 'hashchange', listener);
    });

    globalThis.addEventListener = rawAddEventListener;
    globalThis.removeEventListener = rawRemoveEventListener;

    return function rebuild() {
      // 重新添加监听器
      listeners.forEach((listener) => {
        rawAddEventListener.call(globalThis, 'popstate', listener);
        rawAddEventListener.call(globalThis, 'hashchange', listener);
      });
    };
  };
}
```

## 路由状态流转

```
┌─────────────────────────────────────────────────────────────────┐
│                      应用状态流转                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   NOT_LOADED ──load──▶ LOADING ──▶ NOT_BOOTSTRAPPED             │
│                                           │                      │
│                                      bootstrap                   │
│                                           │                      │
│                                           ▼                      │
│   UNMOUNTING ◀──unmount── MOUNTED ◀──mount── NOT_MOUNTED        │
│       │                      │                    ▲              │
│       │                      │                    │              │
│       └──────────────────────┴────────────────────┘              │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## 路由切换时序

```
┌─────────────────────────────────────────────────────────────────┐
│                      路由切换时序                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   用户点击链接 / 调用 history.push                               │
│        │                                                         │
│        ▼                                                         │
│   pushState 被劫持                                               │
│        │                                                         │
│        ▼                                                         │
│   触发 reroute()                                                 │
│        │                                                         │
│        ├──▶ 计算 appsToUnmount (当前应用不再匹配)                │
│        │         │                                               │
│        │         ▼                                               │
│        │    beforeUnmount → unmount → afterUnmount              │
│        │                                                         │
│        ├──▶ 计算 appsToLoad (新应用需要加载)                     │
│        │         │                                               │
│        │         ▼                                               │
│        │    beforeLoad → loadEntry → bootstrap                  │
│        │                                                         │
│        └──▶ 计算 appsToMount (应用需要挂载)                      │
│                  │                                               │
│                  ▼                                               │
│             beforeMount → mount → afterMount                    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## 常见问题

### 1. 子应用路由 404

```typescript
// 问题：子应用内部路由跳转后刷新页面 404
// 原因：主应用没有配置对应路由

// 解决方案 1：主应用配置通配路由
<Route path="/react/*" element={<div id="container" />} />

// 解决方案 2：Nginx 配置
location /react {
  try_files $uri $uri/ /index.html;
}
```

### 2. 路由冲突

```typescript
// 问题：主应用和子应用路由冲突
// 解决方案：使用不同的路由前缀

// 主应用
<Route path="/main/*" element={<MainApp />} />

// 子应用
activeRule: '/micro'
```

### 3. Hash 路由兼容

```typescript
// 子应用使用 Hash 路由
activeRule: (location) => {
  return location.hash.startsWith('#/react');
}

// 子应用配置
const router = createRouter({
  history: createWebHashHistory(),
  routes: [...],
});
```

## 小结

Qiankun 路由劫持的核心机制：

1. **基于 single-spa**：劫持 pushState/replaceState 和监听 popstate/hashchange
2. **activeRule 匹配**：支持字符串、数组、函数多种匹配方式
3. **状态流转**：NOT_LOADED → LOADING → NOT_MOUNTED → MOUNTED
4. **History 补丁**：沙箱记录子应用的路由监听，卸载时清理

---

> 下一篇：预加载策略
