# Lerna 源码解析：Nx 集成

> 本文分析 Lerna 与 Nx 的集成机制，理解任务缓存和分布式执行的实现。

## Nx 集成概览

```
┌─────────────────────────────────────────────────────────────────┐
│                      Lerna + Nx 架构                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   ┌───────────────────────────────────────────────────────────┐ │
│   │                      Lerna CLI                             │ │
│   │   lerna run | lerna exec | lerna version | lerna publish  │ │
│   └───────────────────────────────────────────────────────────┘ │
│                              │                                   │
│                              ▼                                   │
│   ┌───────────────────────────────────────────────────────────┐ │
│   │                      Nx Core                               │ │
│   │   - Project Graph (依赖图)                                 │ │
│   │   - Task Graph (任务图)                                    │ │
│   │   - Task Runner (任务执行)                                 │ │
│   │   - Cache (本地/远程缓存)                                  │ │
│   └───────────────────────────────────────────────────────────┘ │
│                              │                                   │
│         ┌────────────────────┼────────────────────┐             │
│         ▼                    ▼                    ▼             │
│   ┌─────────────┐     ┌─────────────┐     ┌─────────────┐      │
│   │ Local Cache │     │ Remote Cache│     │ Distributed │      │
│   │  本地缓存    │     │  远程缓存   │     │  分布式执行  │      │
│   └─────────────┘     └─────────────┘     └─────────────┘      │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## 项目图构建

```typescript
// libs/core/src/lib/project-graph-with-packages.ts
export async function buildProjectGraphWithPackages(
  rootPath: string
): Promise<{
  projectGraph: ProjectGraphWithPackages;
  projectFileMap: ProjectFileMap;
}> {
  // 使用 Nx 构建项目图
  const { projectGraph: nxProjectGraph, projectFileMap } = await createProjectGraphAsync();

  // 增强为带 Package 信息的图
  const nodes: Record<string, ProjectGraphProjectNodeWithPackage> = {};
  const localPackageDependencies: Record<string, LocalPackageDependency[]> = {};

  for (const [name, node] of Object.entries(nxProjectGraph.nodes)) {
    const packageJsonPath = path.join(rootPath, node.data.root, "package.json");
    
    let pkg: Package | undefined;
    if (existsSync(packageJsonPath)) {
      const pkgJson = loadJsonFile(packageJsonPath);
      pkg = new Package(pkgJson, path.join(rootPath, node.data.root));
    }

    nodes[name] = { ...node, package: pkg };
  }

  // 分析本地依赖
  for (const [name, deps] of Object.entries(nxProjectGraph.dependencies)) {
    localPackageDependencies[name] = deps
      .filter((dep) => nodes[dep.target]?.package)
      .map((dep) => ({
        source: name,
        target: dep.target,
        targetResolvedNpaResult: npa(nodes[dep.target].package!.name),
      }));
  }

  return {
    projectGraph: { nodes, dependencies: nxProjectGraph.dependencies, localPackageDependencies },
    projectFileMap,
  };
}
```

## 任务执行

### 使用 Nx 执行任务

```typescript
// libs/commands/run/src/index.ts
async runWithNx() {
  const { runMany } = await import("nx/src/command-line/run-many/run-many");

  const result = await runMany({
    targets: [this.script],
    projects: this.packagesWithScript.map((node) => node.name),
    parallel: this.concurrency,
    verbose: this.options.verbose,
    skipNxCache: this.options.skipNxCache,
  });

  if (result.status !== 0) {
    throw new Error(`Script "${this.script}" failed`);
  }
}
```

### Nx 任务配置

```json
// nx.json
{
  "tasksRunnerOptions": {
    "default": {
      "runner": "nx/tasks-runners/default",
      "options": {
        "cacheableOperations": ["build", "test", "lint"],
        "parallel": 3
      }
    }
  },
  "targetDefaults": {
    "build": {
      "dependsOn": ["^build"],
      "inputs": ["production", "^production"],
      "outputs": ["{projectRoot}/dist"]
    },
    "test": {
      "dependsOn": ["build"],
      "inputs": ["default", "^production"]
    }
  }
}
```

## 任务缓存

### 缓存原理

```
┌─────────────────────────────────────────────────────────────────┐
│                      任务缓存原理                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   输入 (Inputs):                                                 │
│   ├── 源代码文件                                                │
│   ├── 依赖的输出                                                │
│   ├── 环境变量                                                  │
│   └── 命令参数                                                  │
│                                                                  │
│         │                                                        │
│         ▼                                                        │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │                    Hash 计算                             │   │
│   │   hash = sha256(inputs)                                 │   │
│   └─────────────────────────────────────────────────────────┘   │
│         │                                                        │
│         ▼                                                        │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │                    缓存查找                              │   │
│   │   cache.get(hash)                                       │   │
│   └─────────────────────────────────────────────────────────┘   │
│         │                                                        │
│    ┌────┴────┐                                                  │
│    ▼         ▼                                                  │
│  命中      未命中                                                │
│    │         │                                                  │
│    ▼         ▼                                                  │
│  恢复输出   执行任务                                             │
│             │                                                    │
│             ▼                                                    │
│          存储缓存                                                │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 缓存配置

```json
// project.json (每个包)
{
  "name": "my-lib",
  "targets": {
    "build": {
      "executor": "@nx/js:tsc",
      "outputs": ["{options.outputPath}"],
      "options": {
        "outputPath": "dist/packages/my-lib"
      },
      "inputs": [
        "production",
        "^production",
        { "externalDependencies": ["typescript"] }
      ]
    }
  }
}
```

### 输入定义

```json
// nx.json
{
  "namedInputs": {
    "default": ["{projectRoot}/**/*", "sharedGlobals"],
    "production": [
      "default",
      "!{projectRoot}/**/*.spec.ts",
      "!{projectRoot}/test/**/*"
    ],
    "sharedGlobals": [
      "{workspaceRoot}/tsconfig.base.json"
    ]
  }
}
```

## 远程缓存

### Nx Cloud 配置

```json
// nx.json
{
  "tasksRunnerOptions": {
    "default": {
      "runner": "@nrwl/nx-cloud",
      "options": {
        "accessToken": "xxx",
        "cacheableOperations": ["build", "test", "lint"]
      }
    }
  }
}
```

### 自托管缓存

```typescript
// 自定义任务运行器
export default async function customTaskRunner(
  tasks: Task[],
  options: DefaultTasksRunnerOptions,
  context: TasksRunnerContext
): Promise<TaskStatus[]> {
  const cache = new CustomCache(options.remoteCache);

  return Promise.all(
    tasks.map(async (task) => {
      const hash = await hashTask(task, context);

      // 检查缓存
      const cached = await cache.get(hash);
      if (cached) {
        await restoreOutputs(task, cached);
        return { status: "cache" };
      }

      // 执行任务
      const result = await runTask(task);

      // 存储缓存
      if (result.status === "success") {
        await cache.set(hash, await collectOutputs(task));
      }

      return result;
    })
  );
}
```

## 分布式执行

### Nx Agents

```yaml
# .github/workflows/ci.yml
name: CI
on: push

jobs:
  main:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: nrwl/nx-set-shas@v4
      - run: npm ci
      
      # 启动 Nx Agents
      - run: npx nx-cloud start-ci-run --distribute-on="3 linux-medium-js"
      
      # 执行任务（自动分布到 agents）
      - run: npx nx affected -t lint test build
      
      # 停止 agents
      - run: npx nx-cloud stop-all-agents
```

### 分布式执行原理

```
┌─────────────────────────────────────────────────────────────────┐
│                      分布式执行                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   Main Agent (协调者)                                            │
│   ┌───────────────────────────────────────────────────────────┐ │
│   │  1. 构建任务图                                             │ │
│   │  2. 分配任务到 agents                                      │ │
│   │  3. 收集结果                                               │ │
│   └───────────────────────────────────────────────────────────┘ │
│                              │                                   │
│         ┌────────────────────┼────────────────────┐             │
│         ▼                    ▼                    ▼             │
│   ┌─────────────┐     ┌─────────────┐     ┌─────────────┐      │
│   │  Agent 1    │     │  Agent 2    │     │  Agent 3    │      │
│   │  build:a    │     │  build:b    │     │  build:c    │      │
│   │  test:a     │     │  test:b     │     │  test:c     │      │
│   └─────────────┘     └─────────────┘     └─────────────┘      │
│         │                    │                    │             │
│         └────────────────────┼────────────────────┘             │
│                              ▼                                   │
│   ┌───────────────────────────────────────────────────────────┐ │
│   │                    Remote Cache                            │ │
│   │   共享构建产物，避免重复执行                                │ │
│   └───────────────────────────────────────────────────────────┘ │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## Lerna + Nx 最佳实践

### 1. 启用缓存

```json
// lerna.json
{
  "useNx": true,
  "$schema": "node_modules/lerna/schemas/lerna-schema.json",
  "version": "independent"
}
```

```json
// nx.json
{
  "tasksRunnerOptions": {
    "default": {
      "runner": "nx/tasks-runners/default",
      "options": {
        "cacheableOperations": ["build", "test", "lint", "e2e"]
      }
    }
  }
}
```

### 2. 定义任务依赖

```json
// nx.json
{
  "targetDefaults": {
    "build": {
      "dependsOn": ["^build"]
    },
    "test": {
      "dependsOn": ["build"]
    },
    "e2e": {
      "dependsOn": ["build"]
    }
  }
}
```

### 3. 使用 affected 命令

```bash
# 只运行受影响的任务
npx nx affected -t build
npx nx affected -t test
npx nx affected -t lint

# 与 lerna 结合
lerna run build --since=main
```

### 4. 配置输入输出

```json
// project.json
{
  "targets": {
    "build": {
      "inputs": [
        "production",
        "^production"
      ],
      "outputs": [
        "{projectRoot}/dist"
      ]
    }
  }
}
```

## 性能对比

```
┌─────────────────────────────────────────────────────────────────┐
│                      性能对比                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   场景: 10 个包，每个包 build 需要 30s                           │
│                                                                  │
│   无缓存 + 串行:                                                 │
│   10 × 30s = 300s (5 分钟)                                      │
│                                                                  │
│   无缓存 + 并行 (4 核):                                          │
│   ≈ 90s (1.5 分钟)                                              │
│                                                                  │
│   有缓存 (无变更):                                               │
│   ≈ 5s (缓存恢复)                                               │
│                                                                  │
│   有缓存 (1 个包变更):                                           │
│   30s (只构建变更的包)                                          │
│                                                                  │
│   分布式 (3 agents):                                            │
│   ≈ 30s (并行 + 缓存)                                           │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## 小结

Lerna + Nx 集成的核心优势：

1. **项目图**：Nx 提供精确的依赖分析
2. **任务缓存**：基于输入哈希的本地/远程缓存
3. **增量执行**：只执行受影响的任务
4. **分布式执行**：支持多 agent 并行执行
5. **无缝集成**：Lerna 命令自动利用 Nx 能力

---

> 系列完结，感谢阅读！
