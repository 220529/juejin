# Lerna 源码解析：版本管理

> 本文深入分析 lerna version 命令的实现，理解版本号管理和 Changelog 生成机制。

## version 命令概览

```
┌─────────────────────────────────────────────────────────────────┐
│                    lerna version 流程                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   1. 检测变更的包                                                │
│      │                                                           │
│      ▼                                                           │
│   2. 确定新版本号                                                │
│      │  - 交互式选择                                             │
│      │  - 语义化提交推断                                         │
│      │  - 命令行指定                                             │
│      ▼                                                           │
│   3. 更新 package.json                                          │
│      │  - 更新版本号                                             │
│      │  - 更新依赖版本                                           │
│      ▼                                                           │
│   4. 生成 CHANGELOG.md                                          │
│      │                                                           │
│      ▼                                                           │
│   5. Git 提交和打标签                                            │
│      │                                                           │
│      ▼                                                           │
│   6. 推送到远程                                                  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## VersionCommand 实现

```typescript
// libs/commands/version/src/index.ts
class VersionCommand extends Command {
  globalVersion?: string;
  updates?: ProjectGraphProjectNodeWithPackage[];
  updatesVersions?: Map<string, string>;
  
  async initialize() {
    // 1. 检查 git 状态
    if (this.requiresGit) {
      await this.verifyWorkingTreeClean();
    }

    // 2. 检测变更的包
    this.updates = collectProjectUpdates(
      this.projectsWithPackage,
      this.projectGraph,
      this.execOpts,
      this.options
    );

    if (!this.updates.length) {
      this.logger.success("", "No changed packages to version");
      return false;
    }

    // 3. 确定版本号
    this.updatesVersions = await this.resolveVersions();

    // 4. 确认
    if (!this.options.yes) {
      const confirmed = await this.confirmVersions();
      if (!confirmed) return false;
    }

    return true;
  }

  async execute() {
    // 1. 更新 package.json
    await this.updatePackageVersions();

    // 2. 生成 Changelog
    if (this.options.conventionalCommits) {
      await this.generateChangelogs();
    }

    // 3. 更新 lerna.json（固定模式）
    if (!this.project.isIndependent()) {
      await this.updateLernaConfig();
    }

    // 4. Git 提交
    await this.gitCommit();

    // 5. Git 打标签
    await this.gitTag();

    // 6. 推送
    if (this.options.push) {
      await this.gitPush();
    }
  }
}
```

## 版本号解析

### 交互式选择

```typescript
async resolveVersions(): Promise<Map<string, string>> {
  const versions = new Map<string, string>();

  if (this.options.conventionalCommits) {
    // 语义化提交推断版本
    return this.resolveConventionalVersions();
  }

  if (this.options.bump) {
    // 命令行指定版本
    return this.resolveBumpVersions(this.options.bump);
  }

  // 交互式选择
  if (this.project.isIndependent()) {
    // 独立模式：每个包单独选择
    for (const node of this.updates) {
      const pkg = getPackage(node);
      const version = await this.promptVersion(pkg.name, pkg.version);
      versions.set(node.name, version);
    }
  } else {
    // 固定模式：统一选择
    const version = await this.promptVersion("all packages", this.project.version);
    for (const node of this.updates) {
      versions.set(node.name, version);
    }
  }

  return versions;
}

async promptVersion(name: string, currentVersion: string): Promise<string> {
  const choices = [
    { name: `Patch (${semver.inc(currentVersion, "patch")})`, value: "patch" },
    { name: `Minor (${semver.inc(currentVersion, "minor")})`, value: "minor" },
    { name: `Major (${semver.inc(currentVersion, "major")})`, value: "major" },
    { name: `Prepatch (${semver.inc(currentVersion, "prepatch")})`, value: "prepatch" },
    { name: `Preminor (${semver.inc(currentVersion, "preminor")})`, value: "preminor" },
    { name: `Premajor (${semver.inc(currentVersion, "premajor")})`, value: "premajor" },
    { name: "Custom Prerelease", value: "prerelease" },
    { name: "Custom Version", value: "custom" },
  ];

  const { bump } = await inquirer.prompt([
    {
      type: "list",
      name: "bump",
      message: `Select a new version for ${name} (currently ${currentVersion})`,
      choices,
    },
  ]);

  if (bump === "custom") {
    const { version } = await inquirer.prompt([
      {
        type: "input",
        name: "version",
        message: "Enter a custom version",
        validate: (v) => semver.valid(v) || "Must be a valid semver version",
      },
    ]);
    return version;
  }

  return semver.inc(currentVersion, bump);
}
```

### 语义化提交推断

```typescript
// libs/core/src/lib/conventional-commits/recommend-version.ts
async resolveConventionalVersions(): Promise<Map<string, string>> {
  const versions = new Map<string, string>();

  for (const node of this.updates) {
    const pkg = getPackage(node);
    
    // 分析 commit 历史
    const recommendation = await conventionalRecommendedBump({
      path: pkg.location,
      preset: "angular",
      tagPrefix: this.tagPrefix,
    });

    // 根据 commit 类型推断版本
    // feat: -> minor
    // fix: -> patch
    // BREAKING CHANGE: -> major
    const releaseType = recommendation.releaseType || "patch";
    const newVersion = semver.inc(pkg.version, releaseType);
    
    versions.set(node.name, newVersion);
  }

  return versions;
}
```

## 更新 package.json

```typescript
async updatePackageVersions(): Promise<void> {
  await pMap(this.updates, async (node) => {
    const pkg = getPackage(node);
    const newVersion = this.updatesVersions.get(node.name);

    // 更新版本号
    pkg.set("version", newVersion);

    // 更新本地依赖版本
    const deps = this.projectGraph.localPackageDependencies[node.name] || [];
    for (const dep of deps) {
      const depVersion = this.updatesVersions.get(dep.target);
      if (depVersion) {
        pkg.updateLocalDependency(
          dep.targetResolvedNpaResult,
          depVersion,
          this.savePrefix
        );
      }
    }

    // 写入文件
    await pkg.serialize();
  });
}
```

## Changelog 生成

```typescript
// libs/core/src/lib/conventional-commits/update-changelog.ts
async generateChangelogs(): Promise<void> {
  if (this.project.isIndependent()) {
    // 独立模式：每个包生成独立 Changelog
    await pMap(this.updates, (node) => this.generatePackageChangelog(node));
  } else {
    // 固定模式：生成根目录 Changelog
    await this.generateRootChangelog();
  }
}

async generatePackageChangelog(node: ProjectGraphProjectNodeWithPackage): Promise<void> {
  const pkg = getPackage(node);
  const changelogPath = path.join(pkg.location, "CHANGELOG.md");
  const newVersion = this.updatesVersions.get(node.name);

  // 生成 Changelog 内容
  const changelog = await conventionalChangelog({
    preset: "angular",
    tagPrefix: `${pkg.name}@`,
    pkg: { path: pkg.manifestLocation },
    releaseCount: 1,
  });

  // 更新 Changelog 文件
  await updateChangelog(changelogPath, changelog, newVersion);
}

async function updateChangelog(
  changelogPath: string,
  newContent: string,
  version: string
): Promise<void> {
  let existingContent = "";
  
  if (existsSync(changelogPath)) {
    existingContent = await readFile(changelogPath, "utf8");
  }

  // 在文件头部插入新内容
  const header = `# Changelog\n\n`;
  const versionHeader = `## ${version} (${new Date().toISOString().split("T")[0]})\n\n`;
  
  const updatedContent = existingContent
    ? existingContent.replace(header, `${header}${versionHeader}${newContent}\n`)
    : `${header}${versionHeader}${newContent}\n`;

  await writeFile(changelogPath, updatedContent);
}
```

## Git 操作

### 提交

```typescript
async gitCommit(): Promise<void> {
  const message = this.options.message || "chore(release): publish";
  
  // 替换占位符
  const formattedMessage = message
    .replace(/%s/g, this.getVersionsForMessage())
    .replace(/%v/g, this.globalVersion || "");

  // 暂存文件
  await this.execGit(["add", "-A"]);

  // 提交
  await this.execGit(["commit", "-m", formattedMessage]);
}

getVersionsForMessage(): string {
  if (this.project.isIndependent()) {
    return Array.from(this.updatesVersions.entries())
      .map(([name, version]) => `${name}@${version}`)
      .join(", ");
  }
  return this.globalVersion;
}
```

### 打标签

```typescript
async gitTag(): Promise<void> {
  if (this.project.isIndependent()) {
    // 独立模式：每个包打独立标签
    for (const [name, version] of this.updatesVersions) {
      const tag = `${name}@${version}`;
      await this.execGit(["tag", tag, "-m", tag]);
    }
  } else {
    // 固定模式：打统一标签
    const tag = `${this.tagPrefix}${this.globalVersion}`;
    await this.execGit(["tag", tag, "-m", tag]);
  }
}
```

### 推送

```typescript
async gitPush(): Promise<void> {
  // 推送提交
  await this.execGit(["push", this.gitRemote, this.currentBranch]);

  // 推送标签
  await this.execGit(["push", this.gitRemote, "--tags"]);
}
```

## 版本模式对比

```
┌─────────────────────────────────────────────────────────────────┐
│                      版本模式对比                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   Fixed Mode (固定模式)                                          │
│   ─────────────────────                                          │
│   lerna.json: "version": "1.0.0"                                │
│                                                                  │
│   变更前:                                                        │
│   ├── package-a@1.0.0                                           │
│   ├── package-b@1.0.0                                           │
│   └── package-c@1.0.0                                           │
│                                                                  │
│   lerna version minor:                                          │
│   ├── package-a@1.1.0  (changed)                                │
│   ├── package-b@1.1.0  (unchanged, but bumped)                  │
│   └── package-c@1.1.0  (unchanged, but bumped)                  │
│                                                                  │
│   Git Tag: v1.1.0                                               │
│                                                                  │
│   ─────────────────────────────────────────────────────────     │
│                                                                  │
│   Independent Mode (独立模式)                                    │
│   ─────────────────────                                          │
│   lerna.json: "version": "independent"                          │
│                                                                  │
│   变更前:                                                        │
│   ├── package-a@1.0.0                                           │
│   ├── package-b@1.2.0                                           │
│   └── package-c@2.0.0                                           │
│                                                                  │
│   lerna version (package-a changed):                            │
│   ├── package-a@1.1.0  (changed, bumped)                        │
│   ├── package-b@1.2.0  (unchanged)                              │
│   └── package-c@2.0.0  (unchanged)                              │
│                                                                  │
│   Git Tags: package-a@1.1.0                                     │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## 预发布版本

```typescript
// 预发布版本处理
async resolvePrerelease(): Promise<Map<string, string>> {
  const { preid = "alpha" } = this.options;
  const versions = new Map<string, string>();

  for (const node of this.updates) {
    const pkg = getPackage(node);
    let newVersion: string;

    if (semver.prerelease(pkg.version)) {
      // 已是预发布版本，递增
      newVersion = semver.inc(pkg.version, "prerelease", preid);
    } else {
      // 新预发布版本
      newVersion = semver.inc(pkg.version, "prerelease", preid);
    }

    versions.set(node.name, newVersion);
  }

  return versions;
}

// 示例
// 1.0.0 -> 1.0.1-alpha.0
// 1.0.1-alpha.0 -> 1.0.1-alpha.1
// 1.0.1-alpha.1 -> 1.0.1-alpha.2
```

## 小结

lerna version 的核心流程：

1. **变更检测**：基于 git 检测变更的包
2. **版本推断**：支持交互式、语义化提交、命令行指定
3. **依赖更新**：自动更新本地依赖的版本号
4. **Changelog**：基于 conventional-commits 生成
5. **Git 操作**：提交、打标签、推送

---

> 下一篇：发布流程
