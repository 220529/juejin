# Lerna 源码解析：变更检测

> 本文深入分析 Lerna 的变更检测机制，理解如何基于 git 识别变更的包。

## 变更检测概览

```
┌─────────────────────────────────────────────────────────────────┐
│                      变更检测流程                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   1. 获取上次发布的 tag                                          │
│      │                                                           │
│      ▼                                                           │
│   2. git diff 获取变更文件                                       │
│      │                                                           │
│      ▼                                                           │
│   3. 映射文件到包                                                │
│      │                                                           │
│      ▼                                                           │
│   4. 分析依赖关系                                                │
│      │  - 直接变更的包                                           │
│      │  - 依赖变更包的包                                         │
│      ▼                                                           │
│   5. 应用过滤条件                                                │
│      │  - --scope                                                │
│      │  - --ignore                                               │
│      │  - --ignore-changes                                       │
│      ▼                                                           │
│   6. 返回变更的包列表                                            │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## collectProjectUpdates

```typescript
// libs/core/src/lib/collect-updates/collect-project-updates.ts
export function collectProjectUpdates(
  projects: ProjectGraphProjectNodeWithPackage[],
  projectGraph: ProjectGraphWithPackages,
  execOpts: ExecOptions,
  options: CollectUpdatesOptions
): ProjectGraphProjectNodeWithPackage[] {
  const {
    forcePublish,
    ignoreChanges,
    includeMergedTags,
  } = options;

  // 1. 强制发布所有包
  if (forcePublish === true) {
    return projects;
  }

  // 2. 强制发布指定包
  if (Array.isArray(forcePublish) && forcePublish.length) {
    const forced = projects.filter((node) => 
      forcePublish.includes(node.name) || forcePublish.includes(getPackage(node).name)
    );
    
    // 加上依赖这些包的包
    return addDependents(forced, projectGraph, projects);
  }

  // 3. 获取变更的包
  const changedProjects = getChangedProjects(
    projects,
    projectGraph,
    execOpts,
    { ignoreChanges, includeMergedTags }
  );

  // 4. 加上依赖变更包的包
  return addDependents(changedProjects, projectGraph, projects);
}
```

## 获取变更的包

```typescript
// libs/core/src/lib/collect-updates/get-changed-projects.ts
function getChangedProjects(
  projects: ProjectGraphProjectNodeWithPackage[],
  projectGraph: ProjectGraphWithPackages,
  execOpts: ExecOptions,
  options: { ignoreChanges?: string[]; includeMergedTags?: boolean }
): ProjectGraphProjectNodeWithPackage[] {
  const { ignoreChanges, includeMergedTags } = options;

  // 1. 获取上次发布的 commit
  const since = getLastCommit(execOpts, includeMergedTags);

  if (!since) {
    // 没有 tag，所有包都是变更的
    return projects;
  }

  // 2. 获取变更的文件
  const changedFiles = getChangedFiles(since, execOpts);

  // 3. 过滤忽略的文件
  const filteredFiles = ignoreChanges
    ? changedFiles.filter((file) => !ignoreChanges.some((pattern) => minimatch(file, pattern)))
    : changedFiles;

  // 4. 映射文件到包
  const changedProjects = new Set<ProjectGraphProjectNodeWithPackage>();

  for (const file of filteredFiles) {
    const project = findProjectForFile(file, projects);
    if (project) {
      changedProjects.add(project);
    }
  }

  return Array.from(changedProjects);
}
```

## 获取上次发布的 commit

```typescript
// libs/core/src/lib/describe-ref.ts
function getLastCommit(
  execOpts: ExecOptions,
  includeMergedTags?: boolean
): string | undefined {
  try {
    // git describe --tags --abbrev=0
    const { stdout } = execSync(
      "git",
      ["describe", "--tags", "--abbrev=0", includeMergedTags ? "--first-parent" : ""].filter(Boolean),
      execOpts
    );
    
    return stdout.trim();
  } catch (err) {
    // 没有 tag
    return undefined;
  }
}

export async function describeRef(
  options: { match?: string; cwd?: string } = {},
  includeMergedTags?: boolean
): Promise<DescribeRefResult> {
  const { match, cwd } = options;

  const args = [
    "describe",
    "--always",
    "--long",
    "--dirty",
    "--first-parent",
  ];

  if (match) {
    args.push("--match", match);
  }

  if (includeMergedTags) {
    // 包含合并的 tag
    args.splice(args.indexOf("--first-parent"), 1);
  }

  const { stdout } = await execa("git", args, { cwd });

  // 解析输出: v1.0.0-5-g1234567
  return parseDescribeRef(stdout.trim());
}

function parseDescribeRef(stdout: string): DescribeRefResult {
  // v1.0.0-5-g1234567-dirty
  const match = stdout.match(/^(.+)-(\d+)-g([0-9a-f]+)(-dirty)?$/);

  if (match) {
    return {
      lastTagName: match[1],
      lastVersion: match[1].replace(/^v/, ""),
      refCount: parseInt(match[2], 10),
      sha: match[3],
      isDirty: !!match[4],
    };
  }

  // 没有 tag，只有 sha
  return {
    lastTagName: undefined,
    lastVersion: undefined,
    refCount: 0,
    sha: stdout.replace(/-dirty$/, ""),
    isDirty: stdout.endsWith("-dirty"),
  };
}
```

## 获取变更的文件

```typescript
function getChangedFiles(since: string, execOpts: ExecOptions): string[] {
  // git diff --name-only <since>
  const { stdout } = execSync(
    "git",
    ["diff", "--name-only", since],
    execOpts
  );

  return stdout
    .split("\n")
    .map((line) => line.trim())
    .filter(Boolean);
}

// 也可以获取暂存区的变更
function getStagedChanges(execOpts: ExecOptions): string[] {
  const { stdout } = execSync(
    "git",
    ["diff", "--cached", "--name-only"],
    execOpts
  );

  return stdout
    .split("\n")
    .map((line) => line.trim())
    .filter(Boolean);
}
```

## 映射文件到包

```typescript
function findProjectForFile(
  file: string,
  projects: ProjectGraphProjectNodeWithPackage[]
): ProjectGraphProjectNodeWithPackage | undefined {
  // 按路径长度排序，优先匹配更深的路径
  const sortedProjects = [...projects].sort(
    (a, b) => b.data.root.length - a.data.root.length
  );

  for (const project of sortedProjects) {
    const projectRoot = project.data.root;
    
    // 文件路径以项目根目录开头
    if (file.startsWith(projectRoot + "/") || file === projectRoot) {
      return project;
    }
  }

  return undefined;
}
```

## 添加依赖者

```typescript
// libs/core/src/lib/add-dependents.ts
export function addDependents(
  changedProjects: ProjectGraphProjectNodeWithPackage[],
  projectGraph: ProjectGraphWithPackages,
  allProjects: ProjectGraphProjectNodeWithPackage[]
): ProjectGraphProjectNodeWithPackage[] {
  const result = new Set(changedProjects);
  const changedNames = new Set(changedProjects.map((p) => p.name));

  // 遍历所有项目，找出依赖变更包的项目
  for (const project of allProjects) {
    if (result.has(project)) continue;

    const deps = projectGraph.localPackageDependencies[project.name] || [];
    
    // 检查是否依赖变更的包
    const dependsOnChanged = deps.some((dep) => changedNames.has(dep.target));
    
    if (dependsOnChanged) {
      result.add(project);
      changedNames.add(project.name);
    }
  }

  // 递归添加（依赖链传递）
  if (result.size > changedProjects.length) {
    return addDependents(Array.from(result), projectGraph, allProjects);
  }

  return Array.from(result);
}
```

## 依赖传递示例

```
┌─────────────────────────────────────────────────────────────────┐
│                      依赖传递示例                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   项目结构:                                                      │
│   ├── package-a (无依赖)                                        │
│   ├── package-b (依赖 package-a)                                │
│   └── package-c (依赖 package-b)                                │
│                                                                  │
│   依赖图:                                                        │
│   package-a ◀── package-b ◀── package-c                         │
│                                                                  │
│   场景: package-a 有变更                                         │
│                                                                  │
│   第一轮:                                                        │
│   - changedProjects: [package-a]                                │
│   - 检查 package-b: 依赖 package-a ✓ → 添加                     │
│   - 检查 package-c: 依赖 package-b ✗                            │
│   - result: [package-a, package-b]                              │
│                                                                  │
│   第二轮 (递归):                                                 │
│   - changedProjects: [package-a, package-b]                     │
│   - 检查 package-c: 依赖 package-b ✓ → 添加                     │
│   - result: [package-a, package-b, package-c]                   │
│                                                                  │
│   最终: 所有包都需要发布                                         │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## 过滤选项

### --scope

```typescript
// 只包含指定的包
function filterByScope(
  projects: ProjectGraphProjectNodeWithPackage[],
  scope: string[]
): ProjectGraphProjectNodeWithPackage[] {
  return projects.filter((project) => {
    const pkg = getPackage(project);
    return scope.some((pattern) => minimatch(pkg.name, pattern));
  });
}

// 使用示例
// lerna version --scope=@myorg/*
// lerna version --scope=package-a --scope=package-b
```

### --ignore

```typescript
// 排除指定的包
function filterByIgnore(
  projects: ProjectGraphProjectNodeWithPackage[],
  ignore: string[]
): ProjectGraphProjectNodeWithPackage[] {
  return projects.filter((project) => {
    const pkg = getPackage(project);
    return !ignore.some((pattern) => minimatch(pkg.name, pattern));
  });
}

// 使用示例
// lerna version --ignore=@myorg/internal-*
```

### --ignore-changes

```typescript
// 忽略指定文件的变更
function filterChangedFiles(
  files: string[],
  ignoreChanges: string[]
): string[] {
  return files.filter((file) => {
    return !ignoreChanges.some((pattern) => minimatch(file, pattern));
  });
}

// 使用示例
// lerna version --ignore-changes="**/*.md" --ignore-changes="**/__tests__/**"
```

## lerna changed 命令

```typescript
// libs/commands/changed/src/index.ts
class ChangedCommand extends Command {
  async initialize() {
    // 获取变更的包
    this.updates = collectProjectUpdates(
      this.projectsWithPackage,
      this.projectGraph,
      this.execOpts,
      this.options
    );

    if (!this.updates.length) {
      this.logger.info("", "No changed packages found");
      return false;
    }

    return true;
  }

  async execute() {
    // 输出变更的包
    const packages = this.updates.map((node) => getPackage(node));
    
    if (this.options.json) {
      output(JSON.stringify(packages.map((pkg) => ({
        name: pkg.name,
        version: pkg.version,
        private: pkg.private,
        location: pkg.location,
      })), null, 2));
    } else {
      packages.forEach((pkg) => {
        output(pkg.name);
      });
    }
  }
}
```

## 变更检测配置

```json
// lerna.json
{
  "command": {
    "version": {
      "ignoreChanges": [
        "**/*.md",
        "**/__tests__/**",
        "**/test/**"
      ]
    },
    "publish": {
      "ignoreChanges": [
        "**/*.md"
      ]
    }
  }
}
```

## 小结

Lerna 变更检测的核心机制：

1. **基于 Git**：通过 git describe 获取上次 tag，git diff 获取变更文件
2. **文件映射**：将变更文件映射到对应的包
3. **依赖传递**：递归添加依赖变更包的包
4. **过滤选项**：scope、ignore、ignore-changes 灵活过滤

---

> 下一篇：任务编排
