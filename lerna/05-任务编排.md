# Lerna 源码解析：任务编排

> 本文深入分析 Lerna 的任务编排机制，理解 lerna run 和 lerna exec 的拓扑排序执行。

## 任务编排概览

```
┌─────────────────────────────────────────────────────────────────┐
│                      任务编排流程                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   1. 收集目标包                                                  │
│      │  - --scope 过滤                                          │
│      │  - --ignore 排除                                         │
│      ▼                                                           │
│   2. 拓扑排序                                                    │
│      │  - 分析依赖关系                                           │
│      │  - 确定执行顺序                                           │
│      ▼                                                           │
│   3. 并行执行                                                    │
│      │  - 尊重依赖顺序                                           │
│      │  - 控制并发数                                             │
│      ▼                                                           │
│   4. 输出结果                                                    │
│      │  - --stream 流式输出                                      │
│      │  - 汇总执行结果                                           │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## lerna run 命令

```typescript
// libs/commands/run/src/index.ts
class RunCommand extends Command {
  script: string;
  packagesWithScript: ProjectGraphProjectNodeWithPackage[];

  async initialize() {
    this.script = this.options.script;

    // 1. 过滤有该脚本的包
    this.packagesWithScript = this.projectsWithPackage.filter((node) => {
      const pkg = getPackage(node);
      return pkg.scripts?.[this.script];
    });

    if (!this.packagesWithScript.length) {
      this.logger.warn("run", `No packages found with script "${this.script}"`);
      return false;
    }

    // 2. 应用 scope/ignore 过滤
    if (this.options.scope) {
      this.packagesWithScript = filterByScope(this.packagesWithScript, this.options.scope);
    }
    if (this.options.ignore) {
      this.packagesWithScript = filterByIgnore(this.packagesWithScript, this.options.ignore);
    }

    return true;
  }

  async execute() {
    // 使用 Nx 执行（如果可用）
    if (this.options.useNx !== false) {
      return this.runWithNx();
    }

    // 使用 Lerna 原生执行
    return this.runWithLerna();
  }

  async runWithLerna() {
    const runner = this.options.stream
      ? this.runScriptInPackageStreaming
      : this.runScriptInPackage;

    if (this.toposort) {
      // 拓扑排序执行
      await runProjectsTopologically(
        this.packagesWithScript,
        this.projectGraph,
        runner,
        { concurrency: this.concurrency }
      );
    } else {
      // 并行执行（不考虑依赖顺序）
      await pMap(this.packagesWithScript, runner, { concurrency: this.concurrency });
    }
  }

  async runScriptInPackage(node: ProjectGraphProjectNodeWithPackage) {
    const pkg = getPackage(node);
    
    return npmRunScript(this.script, {
      args: this.options["--"],
      pkg,
      npmClient: this.options.npmClient,
    });
  }

  async runScriptInPackageStreaming(node: ProjectGraphProjectNodeWithPackage) {
    const pkg = getPackage(node);
    
    return npmRunScriptStreaming(this.script, {
      args: this.options["--"],
      pkg,
      npmClient: this.options.npmClient,
      prefix: this.options.prefix,
    });
  }
}
```

## lerna exec 命令

```typescript
// libs/commands/exec/src/index.ts
class ExecCommand extends Command {
  command: string;
  args: string[];

  async initialize() {
    const [command, ...args] = this.options["--"] || [];
    
    if (!command) {
      throw new ValidationError("ENOCOMMAND", "A command is required");
    }

    this.command = command;
    this.args = args;

    return true;
  }

  async execute() {
    const runner = this.options.stream
      ? this.execInPackageStreaming
      : this.execInPackage;

    if (this.toposort) {
      await runProjectsTopologically(
        this.projectsWithPackage,
        this.projectGraph,
        runner,
        { concurrency: this.concurrency }
      );
    } else {
      await pMap(this.projectsWithPackage, runner, { concurrency: this.concurrency });
    }
  }

  async execInPackage(node: ProjectGraphProjectNodeWithPackage) {
    const pkg = getPackage(node);
    
    return execa(this.command, this.args, {
      cwd: pkg.location,
      env: {
        ...process.env,
        LERNA_PACKAGE_NAME: pkg.name,
        LERNA_ROOT_PATH: this.project.rootPath,
      },
    });
  }

  async execInPackageStreaming(node: ProjectGraphProjectNodeWithPackage) {
    const pkg = getPackage(node);
    
    return execa(this.command, this.args, {
      cwd: pkg.location,
      stdio: "inherit",
      env: {
        ...process.env,
        LERNA_PACKAGE_NAME: pkg.name,
        LERNA_ROOT_PATH: this.project.rootPath,
      },
    });
  }
}
```

## 拓扑排序执行

```typescript
// libs/core/src/lib/run-projects-topologically.ts
export async function runProjectsTopologically<T>(
  projects: ProjectGraphProjectNodeWithPackage[],
  projectGraph: ProjectGraphWithPackages,
  runner: (node: ProjectGraphProjectNodeWithPackage) => Promise<T>,
  options: { concurrency: number; rejectCycles?: boolean }
): Promise<T[]> {
  const { concurrency, rejectCycles } = options;

  // 1. 检测循环依赖
  if (rejectCycles) {
    const cycles = detectCycles(projects, projectGraph);
    if (cycles.length) {
      throw new ValidationError(
        "ECYCLE",
        `Dependency cycles detected:\n${cycles.map((c) => c.join(" -> ")).join("\n")}`
      );
    }
  }

  // 2. 拓扑排序
  const sorted = toposortProjects(projects, projectGraph);

  // 3. 构建执行计划
  const results: T[] = [];
  const completed = new Set<string>();
  const inProgress = new Map<string, Promise<T>>();

  // 4. 使用队列控制并发
  const queue = new PQueue({ concurrency });

  for (const node of sorted) {
    queue.add(async () => {
      // 等待依赖完成
      const deps = projectGraph.localPackageDependencies[node.name] || [];
      const depPromises = deps
        .filter((dep) => inProgress.has(dep.target))
        .map((dep) => inProgress.get(dep.target));
      
      await Promise.all(depPromises);

      // 执行任务
      const promise = runner(node);
      inProgress.set(node.name, promise);

      try {
        const result = await promise;
        results.push(result);
        completed.add(node.name);
      } finally {
        inProgress.delete(node.name);
      }
    });
  }

  await queue.onIdle();
  return results;
}
```

## 拓扑排序算法

```typescript
// libs/core/src/lib/toposort-projects.ts
export function toposortProjects(
  projects: ProjectGraphProjectNodeWithPackage[],
  projectGraph: ProjectGraphWithPackages
): ProjectGraphProjectNodeWithPackage[] {
  const projectNames = new Set(projects.map((p) => p.name));
  const sorted: ProjectGraphProjectNodeWithPackage[] = [];
  const visited = new Set<string>();
  const visiting = new Set<string>();

  function visit(node: ProjectGraphProjectNodeWithPackage) {
    const name = node.name;

    // 已访问，跳过
    if (visited.has(name)) return;

    // 正在访问，说明有循环
    if (visiting.has(name)) {
      throw new Error(`Circular dependency detected: ${name}`);
    }

    visiting.add(name);

    // 先访问依赖
    const deps = projectGraph.localPackageDependencies[name] || [];
    for (const dep of deps) {
      // 只处理在目标列表中的依赖
      if (projectNames.has(dep.target)) {
        const depNode = projectGraph.nodes[dep.target];
        visit(depNode);
      }
    }

    visiting.delete(name);
    visited.add(name);
    sorted.push(node);
  }

  for (const project of projects) {
    visit(project);
  }

  return sorted;
}
```

## 循环依赖检测

```typescript
// libs/core/src/lib/cycles/detect-cycles.ts
export function detectCycles(
  projects: ProjectGraphProjectNodeWithPackage[],
  projectGraph: ProjectGraphWithPackages
): string[][] {
  const cycles: string[][] = [];
  const projectNames = new Set(projects.map((p) => p.name));
  const visited = new Set<string>();
  const path: string[] = [];

  function dfs(name: string) {
    if (visited.has(name)) return;

    const pathIndex = path.indexOf(name);
    if (pathIndex !== -1) {
      // 发现循环
      cycles.push([...path.slice(pathIndex), name]);
      return;
    }

    path.push(name);

    const deps = projectGraph.localPackageDependencies[name] || [];
    for (const dep of deps) {
      if (projectNames.has(dep.target)) {
        dfs(dep.target);
      }
    }

    path.pop();
    visited.add(name);
  }

  for (const project of projects) {
    dfs(project.name);
  }

  return cycles;
}
```

## 执行顺序示例

```
┌─────────────────────────────────────────────────────────────────┐
│                      执行顺序示例                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   依赖关系:                                                      │
│   ├── utils (无依赖)                                            │
│   ├── core (依赖 utils)                                         │
│   ├── cli (依赖 core)                                           │
│   └── web (依赖 core)                                           │
│                                                                  │
│   依赖图:                                                        │
│                    utils                                         │
│                      │                                           │
│                      ▼                                           │
│                    core                                          │
│                    /   \                                         │
│                   ▼     ▼                                        │
│                 cli    web                                       │
│                                                                  │
│   拓扑排序: [utils, core, cli, web]                             │
│                                                                  │
│   执行过程 (concurrency=2):                                      │
│   ─────────────────────────────────────────────────────────     │
│   T1: utils 开始                                                │
│   T2: utils 完成                                                │
│   T3: core 开始                                                 │
│   T4: core 完成                                                 │
│   T5: cli 开始, web 开始 (并行)                                 │
│   T6: cli 完成, web 完成                                        │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## 流式输出

```typescript
// libs/core/src/lib/npm-run-script.ts
export async function npmRunScriptStreaming(
  script: string,
  options: {
    pkg: Package;
    args?: string[];
    npmClient?: string;
    prefix?: boolean;
  }
): Promise<void> {
  const { pkg, args = [], npmClient = "npm", prefix = true } = options;

  const child = execa(npmClient, ["run", script, ...args], {
    cwd: pkg.location,
    stdio: ["inherit", "pipe", "pipe"],
  });

  // 添加前缀
  if (prefix) {
    const prefixStr = `[${pkg.name}] `;
    
    child.stdout?.on("data", (data) => {
      const lines = data.toString().split("\n");
      lines.forEach((line) => {
        if (line) {
          process.stdout.write(`${prefixStr}${line}\n`);
        }
      });
    });

    child.stderr?.on("data", (data) => {
      const lines = data.toString().split("\n");
      lines.forEach((line) => {
        if (line) {
          process.stderr.write(`${prefixStr}${line}\n`);
        }
      });
    });
  } else {
    child.stdout?.pipe(process.stdout);
    child.stderr?.pipe(process.stderr);
  }

  await child;
}
```

## Nx 集成

```typescript
// 使用 Nx 执行任务
async runWithNx() {
  const { runMany } = await import("nx/src/command-line/run-many/run-many");

  await runMany({
    targets: [this.script],
    projects: this.packagesWithScript.map((node) => node.name),
    parallel: this.concurrency,
    verbose: this.options.verbose,
  });
}
```

Nx 集成的优势：
- **任务缓存**：相同输入跳过执行
- **分布式执行**：支持远程缓存和分布式任务
- **增量构建**：只构建变更的部分

## 命令行选项

```bash
# 基本用法
lerna run build
lerna exec -- rm -rf dist

# 过滤
lerna run build --scope=@myorg/*
lerna run test --ignore=@myorg/internal-*

# 并发控制
lerna run build --concurrency=4
lerna run build --no-sort  # 不拓扑排序

# 输出控制
lerna run build --stream   # 流式输出
lerna run build --prefix   # 添加包名前缀

# 传递参数
lerna run test -- --coverage
lerna exec -- npm update
```

## 小结

Lerna 任务编排的核心机制：

1. **拓扑排序**：按依赖顺序执行，确保依赖先构建
2. **并发控制**：使用队列控制并发数，尊重依赖顺序
3. **循环检测**：检测并报告循环依赖
4. **流式输出**：实时输出执行日志，支持前缀区分
5. **Nx 集成**：利用 Nx 实现缓存和分布式执行

---

> 下一篇：Nx 集成
