# Qiankun 微前端源码解析：预加载策略

> 本文分析 Qiankun 的预加载机制，理解如何优化子应用的加载性能。

## 预加载概览

```
┌─────────────────────────────────────────────────────────────────┐
│                      预加载策略                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │                    prefetch 配置                         │   │
│   │                                                          │   │
│   │   true          - 主应用 start 后预加载所有子应用        │   │
│   │   'all'         - 主应用 start 后预加载所有子应用        │   │
│   │   string[]      - 预加载指定的子应用                     │   │
│   │   function      - 自定义预加载策略                       │   │
│   │                                                          │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                  │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │                    预加载时机                            │   │
│   │                                                          │   │
│   │   - 主应用首屏加载完成后                                 │   │
│   │   - 浏览器空闲时（requestIdleCallback）                  │   │
│   │   - 用户交互时（hover、focus）                           │   │
│   │                                                          │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## 预加载配置

### start 配置

```typescript
import { registerMicroApps, start } from 'qiankun';

registerMicroApps([
  { name: 'react-app', entry: '//localhost:7100', ... },
  { name: 'vue-app', entry: '//localhost:7200', ... },
]);

// 预加载所有子应用
start({ prefetch: true });

// 或指定预加载的应用
start({ prefetch: ['react-app'] });

// 或自定义预加载策略
start({
  prefetch: (apps) => ({
    criticalAppNames: ['react-app'],  // 关键应用，立即预加载
    minorAppNames: ['vue-app'],       // 次要应用，空闲时预加载
  }),
});
```

## 预加载实现（2.x 参考）

```typescript
// 预加载策略
export function doPrefetchStrategy(
  apps: Array<RegistrableApp<any>>,
  prefetchStrategy: PrefetchStrategy,
  importEntryOpts?: ImportEntryOpts,
) {
  const appsName2Apps = (names: string[]) => 
    apps.filter((app) => names.includes(app.name));

  if (Array.isArray(prefetchStrategy)) {
    // 预加载指定应用
    prefetchAfterFirstMounted(appsName2Apps(prefetchStrategy), importEntryOpts);
  } else if (isFunction(prefetchStrategy)) {
    // 自定义策略
    const { criticalAppNames = [], minorAppNames = [] } = prefetchStrategy(apps);
    
    // 关键应用立即预加载
    prefetchImmediately(appsName2Apps(criticalAppNames), importEntryOpts);
    // 次要应用首屏后预加载
    prefetchAfterFirstMounted(appsName2Apps(minorAppNames), importEntryOpts);
  } else {
    // 默认：首屏后预加载所有
    switch (prefetchStrategy) {
      case true:
        prefetchAfterFirstMounted(apps, importEntryOpts);
        break;
      case 'all':
        prefetchImmediately(apps, importEntryOpts);
        break;
    }
  }
}
```

### 首屏后预加载

```typescript
function prefetchAfterFirstMounted(
  apps: Array<RegistrableApp<any>>,
  opts?: ImportEntryOpts,
) {
  // 监听第一个应用挂载完成
  window.addEventListener('single-spa:first-mount', function listener() {
    // 获取未加载的应用
    const notLoadedApps = apps.filter(
      (app) => getAppStatus(app.name) === 'NOT_LOADED'
    );

    if (process.env.NODE_ENV === 'development') {
      console.log('[qiankun] prefetch apps:', notLoadedApps.map((app) => app.name));
    }

    // 使用 requestIdleCallback 在空闲时预加载
    notLoadedApps.forEach(({ entry }) => prefetch(entry, opts));

    window.removeEventListener('single-spa:first-mount', listener);
  });
}
```

### 立即预加载

```typescript
function prefetchImmediately(
  apps: Array<RegistrableApp<any>>,
  opts?: ImportEntryOpts,
) {
  if (process.env.NODE_ENV === 'development') {
    console.log('[qiankun] prefetch apps immediately:', apps.map((app) => app.name));
  }

  apps.forEach(({ entry }) => prefetch(entry, opts));
}
```

### prefetch 核心实现

```typescript
function prefetch(entry: string, opts?: ImportEntryOpts) {
  // 使用 requestIdleCallback 在浏览器空闲时执行
  requestIdleCallback(async () => {
    // 获取子应用的静态资源
    const { getExternalScripts, getExternalStyleSheets } = await importEntry(entry, opts);

    // 预加载样式
    requestIdleCallback(getExternalStyleSheets);
    // 预加载脚本
    requestIdleCallback(getExternalScripts);
  });
}
```

## requestIdleCallback

```typescript
// requestIdleCallback polyfill
const requestIdleCallback =
  window.requestIdleCallback ||
  function(cb: IdleRequestCallback) {
    const start = Date.now();
    return setTimeout(() => {
      cb({
        didTimeout: false,
        timeRemaining() {
          return Math.max(0, 50 - (Date.now() - start));
        },
      });
    }, 1);
  };
```

## 预加载流程图

```
┌─────────────────────────────────────────────────────────────────┐
│                      预加载流程                                  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
              ┌───────────────────────────────┐
              │     1. start({ prefetch })    │
              │   解析预加载配置               │
              └───────────────────────────────┘
                              │
                              ▼
              ┌───────────────────────────────┐
              │     2. 等待首屏加载完成        │
              │   single-spa:first-mount      │
              └───────────────────────────────┘
                              │
                              ▼
              ┌───────────────────────────────┐
              │     3. requestIdleCallback    │
              │   浏览器空闲时执行             │
              └───────────────────────────────┘
                              │
                              ▼
              ┌───────────────────────────────┐
              │     4. importEntry            │
              │   获取子应用资源列表           │
              └───────────────────────────────┘
                              │
              ┌───────────────┴───────────────┐
              ▼                               ▼
┌─────────────────────────┐     ┌─────────────────────────┐
│  5a. getExternalStyles  │     │  5b. getExternalScripts │
│  预加载样式文件          │     │  预加载脚本文件          │
└─────────────────────────┘     └─────────────────────────┘
```

## 资源预加载方式

### Link Prefetch

```typescript
function prefetchAssets(urls: string[]) {
  urls.forEach((url) => {
    const link = document.createElement('link');
    link.rel = 'prefetch';
    link.href = url;
    document.head.appendChild(link);
  });
}
```

### Fetch 预加载

```typescript
async function prefetchWithFetch(urls: string[]) {
  await Promise.all(
    urls.map((url) =>
      fetch(url, { credentials: 'include' })
        .then((res) => res.text())
        .catch((err) => console.warn('[qiankun] prefetch error:', err))
    )
  );
}
```

## 自定义预加载策略

### 基于路由的预加载

```typescript
start({
  prefetch: (apps) => {
    const currentPath = window.location.pathname;
    
    // 根据当前路由预测下一个可能访问的应用
    const nextApps = predictNextApps(currentPath, apps);
    
    return {
      criticalAppNames: nextApps.slice(0, 1).map((app) => app.name),
      minorAppNames: nextApps.slice(1).map((app) => app.name),
    };
  },
});

function predictNextApps(currentPath: string, apps: App[]) {
  // 基于用户行为数据预测
  const predictions = {
    '/': ['dashboard', 'user'],
    '/dashboard': ['report', 'settings'],
    '/user': ['profile', 'settings'],
  };
  
  const predictedNames = predictions[currentPath] || [];
  return apps.filter((app) => predictedNames.includes(app.name));
}
```

### 基于用户交互的预加载

```typescript
// 鼠标悬停时预加载
document.querySelectorAll('[data-prefetch]').forEach((el) => {
  el.addEventListener('mouseenter', () => {
    const appName = el.getAttribute('data-prefetch');
    const app = apps.find((a) => a.name === appName);
    if (app) {
      prefetch(app.entry);
    }
  });
});
```

### 基于网络状况的预加载

```typescript
start({
  prefetch: (apps) => {
    // 检查网络状况
    const connection = (navigator as any).connection;
    
    if (connection) {
      // 慢速网络不预加载
      if (connection.saveData || connection.effectiveType === 'slow-2g') {
        return { criticalAppNames: [], minorAppNames: [] };
      }
      
      // 快速网络预加载所有
      if (connection.effectiveType === '4g') {
        return {
          criticalAppNames: apps.map((app) => app.name),
          minorAppNames: [],
        };
      }
    }
    
    // 默认策略
    return {
      criticalAppNames: [],
      minorAppNames: apps.map((app) => app.name),
    };
  },
});
```

## 预加载优化建议

### 1. 分级预加载

```typescript
start({
  prefetch: (apps) => {
    // 高优先级：用户最可能访问的应用
    const critical = apps.filter((app) => app.priority === 'high');
    // 低优先级：其他应用
    const minor = apps.filter((app) => app.priority !== 'high');
    
    return {
      criticalAppNames: critical.map((app) => app.name),
      minorAppNames: minor.map((app) => app.name),
    };
  },
});
```

### 2. 避免重复预加载

```typescript
const prefetchedApps = new Set<string>();

function prefetchOnce(entry: string, appName: string) {
  if (prefetchedApps.has(appName)) {
    return;
  }
  
  prefetchedApps.add(appName);
  prefetch(entry);
}
```

### 3. 预加载进度监控

```typescript
async function prefetchWithProgress(apps: App[]) {
  let loaded = 0;
  const total = apps.length;

  await Promise.all(
    apps.map(async (app) => {
      await prefetch(app.entry);
      loaded++;
      console.log(`[qiankun] prefetch progress: ${loaded}/${total}`);
    })
  );
}
```

## 性能对比

```
┌─────────────────────────────────────────────────────────────────┐
│                      预加载性能对比                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   场景                    无预加载        有预加载               │
│   ─────────────────────────────────────────────────────────     │
│   首次加载子应用           2000ms          500ms                 │
│   切换子应用               1500ms          200ms                 │
│   主应用首屏               500ms           500ms                 │
│   总资源加载               按需            提前                  │
│                                                                  │
│   优点：                                                         │
│   - 子应用切换更快                                               │
│   - 用户体验更流畅                                               │
│                                                                  │
│   缺点：                                                         │
│   - 增加初始带宽消耗                                             │
│   - 可能加载不需要的资源                                         │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## 小结

Qiankun 预加载策略的核心要点：

1. **多种配置方式**：true、'all'、数组、函数
2. **空闲时加载**：使用 requestIdleCallback 避免阻塞主线程
3. **分级预加载**：关键应用立即加载，次要应用空闲时加载
4. **自定义策略**：支持基于路由、用户行为、网络状况的预加载

---

> 系列完结，感谢阅读！
