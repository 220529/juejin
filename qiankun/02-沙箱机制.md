# Qiankun 微前端源码解析：沙箱机制

> 本文深入分析 Qiankun 3.0 的 JS 沙箱实现，理解 Proxy 代理和 Membrane 模式。

## 沙箱架构

```
┌─────────────────────────────────────────────────────────────────┐
│                      @qiankunjs/sandbox                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                   StandardSandbox                        │    │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────┐  │    │
│  │  │ Compartment │  │  Membrane   │  │    Patchers     │  │    │
│  │  │  代码执行    │  │  Proxy 代理 │  │  副作用补丁     │  │    │
│  │  └─────────────┘  └─────────────┘  └─────────────────┘  │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## createSandboxContainer

沙箱容器的创建入口：

```typescript
// packages/sandbox/src/core/sandbox/index.ts
export function createSandboxContainer(
  appName: string,
  getContainer: () => HTMLElement,
  opts: {
    globalContext?: WindowProxy;
    extraGlobals?: Endowments;
  } & Pick<SandboxConfig, 'fetch' | 'nodeTransformer'>,
) {
  const { globalContext, extraGlobals = {}, ...sandboxCfg } = opts;
  
  // 创建 StandardSandbox
  const sandbox = new StandardSandbox(appName, extraGlobals, globalContext);

  // 启动阶段的补丁（动态样式注入等）
  const bootstrappingFrees = patchAtBootstrapping(appName, getContainer, { sandbox, ...sandboxCfg });
  
  let mountingFrees: Free[] = [];
  let sideEffectsRebuilds: Rebuild[] = [];

  return {
    instance: sandbox,

    async mount(container: HTMLElement) {
      // 1. 激活沙箱
      sandbox.active();

      // 2. 恢复启动阶段的副作用
      const sideEffectsRebuildsAtBootstrapping = sideEffectsRebuilds.slice(0, bootstrappingFrees.length);
      for (const rebuild of sideEffectsRebuildsAtBootstrapping) {
        await rebuild(container);
      }

      // 3. 挂载阶段的补丁（事件监听、定时器等）
      mountingFrees = patchAtMounting(appName, getContainer, { sandbox, ...sandboxCfg });

      // 4. 恢复挂载阶段的副作用
      const sideEffectsRebuildsAtMounting = sideEffectsRebuilds.slice(bootstrappingFrees.length);
      for (const rebuild of sideEffectsRebuildsAtMounting) {
        await rebuild(container);
      }

      sideEffectsRebuilds = [];
    },

    async unmount() {
      // 记录副作用重建函数
      sideEffectsRebuilds = [...bootstrappingFrees, ...mountingFrees].map((free) => free());
      // 冻结沙箱
      sandbox.inactive();
    },
  };
}
```

## StandardSandbox

标准沙箱实现，继承自 Compartment：

```typescript
// packages/sandbox/src/core/sandbox/StandardSandbox.ts
export class StandardSandbox extends Compartment implements Sandbox {
  private readonly membrane: Membrane;
  readonly type = SandboxType.Standard;
  readonly name: string;

  constructor(name: string, globals: Endowments, incubatorContext: WindowProxy = window) {
    const getRealmGlobal = () => realmGlobal;
    
    // 定义内置属性
    const intrinsics: Record<string, PropertyDescriptor> = {
      // 防止通过 window.window 逃逸沙箱
      window: { get: getRealmGlobal, enumerable: true, configurable: false },
      self: { get: getRealmGlobal, enumerable: true, configurable: false },
      globalThis: { get: getRealmGlobal, enumerable: false, configurable: true },

      // hasOwnProperty 特殊处理
      hasOwnProperty: {
        value: function(key: PropertyKey): boolean {
          if (this !== realmGlobal && this !== null && typeof this === 'object') {
            return hasOwnProperty(this, key);
          }
          return hasOwnProperty(target, key) || hasOwnProperty(incubatorContext, key);
        },
      },

      // eval 保持原生
      eval: { value: eval },

      // top/parent 处理 iframe 场景
      top: {
        get() {
          if (incubatorContext === incubatorContext.parent) {
            return realmGlobal;
          }
          return incubatorContext.top;
        },
      },
      parent: {
        get() {
          if (incubatorContext === incubatorContext.parent) {
            return realmGlobal;
          }
          return incubatorContext.parent;
        },
      },

      document: { value: document, writable: true },
    };

    // 创建 Membrane 代理
    const membrane = new Membrane(incubatorContext, unscopables, {
      whitelist: [],
      endowments: { ...intrinsics, ...globals },
    });

    const { realmGlobal, target } = membrane;
    super(realmGlobal);

    this.name = name;
    this.membrane = membrane;
  }

  get latestSetProp() {
    return this.membrane.latestSetProp;
  }

  active() {
    this.membrane.unlock();
  }

  inactive() {
    this.membrane.lock();
  }
}
```

## Membrane 代理模式

Membrane 是沙箱的核心，通过 Proxy 实现属性隔离：

```
┌─────────────────────────────────────────────────────────────────┐
│                        Membrane                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   ┌─────────────┐         ┌─────────────┐                       │
│   │   target    │ ──────▶ │   Proxy     │ ──────▶ realmGlobal   │
│   │ (原始对象)   │         │  (代理层)   │         (沙箱全局)     │
│   └─────────────┘         └─────────────┘                       │
│                                 │                                │
│                                 ▼                                │
│                    ┌─────────────────────────┐                  │
│                    │      Handler            │                  │
│                    │  - get: 读取属性        │                  │
│                    │  - set: 设置属性        │                  │
│                    │  - has: in 操作符       │                  │
│                    │  - deleteProperty       │                  │
│                    └─────────────────────────┘                  │
│                                                                  │
│   modifications: Map<PropertyKey, unknown>  // 记录修改         │
│   latestSetProp: PropertyKey               // 最后设置的属性     │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Proxy Handler 实现

```typescript
const handler: ProxyHandler<Window> = {
  get(target, p, receiver) {
    // 1. 优先从 endowments 获取
    if (p in endowments) {
      const descriptor = endowments[p];
      if (descriptor.get) {
        return descriptor.get.call(receiver);
      }
      return descriptor.value;
    }

    // 2. 从 modifications 获取（沙箱内修改的值）
    if (modifications.has(p)) {
      return modifications.get(p);
    }

    // 3. 从原始 window 获取
    const value = Reflect.get(target, p, receiver);
    
    // 4. 函数需要绑定 this
    if (typeof value === 'function' && !isConstructor(value)) {
      return value.bind(target);
    }

    return value;
  },

  set(target, p, value, receiver) {
    // 沙箱锁定时禁止修改
    if (locked) {
      return false;
    }

    // 记录修改
    modifications.set(p, value);
    latestSetProp = p;

    return true;
  },

  has(target, p) {
    // unscopables 中的属性返回 false，使其能访问外部作用域
    if (p in unscopables) {
      return false;
    }
    return p in endowments || p in target;
  },

  deleteProperty(target, p) {
    if (modifications.has(p)) {
      modifications.delete(p);
      return true;
    }
    return false;
  },
};
```

## Compartment 代码执行

Compartment 负责在沙箱环境中执行代码：

```typescript
// packages/sandbox/src/core/compartment/index.ts
export class Compartment {
  private readonly id: CompartmentGlobalId;
  private readonly _globalThis: WindowProxy;
  private constantIntrinsicNames: string[] = [];

  constructor(globalProxy: WindowProxy) {
    this._globalThis = globalProxy;
    
    // 生成唯一 ID
    this.id = getCompartmentGlobalId(compartmentCounter);
    // 将代理对象挂载到原生 window
    nativeGlobal[this.id] = globalProxy;
  }

  get globalThis(): WindowProxy {
    return this._globalThis;
  }

  // 生成执行代码的工厂函数
  makeEvaluateFactory(source: string, sourceURL?: string): string {
    const sourceMapURL = sourceURL ? `//# sourceURL=${sourceURL}\n` : '';
    
    // 优化：将常用全局变量解构出来
    const globalObjectOptimizer = this.constantIntrinsicNames.length
      ? `const {${this.constantIntrinsicNames.join(',')}} = this;`
      : '';

    // 使用 with 语句绑定作用域
    return `;(function(){with(this){${globalObjectOptimizer}${source}\n${sourceMapURL}}}).bind(window.${this.id})();`;
  }
}
```

### 代码执行原理

```javascript
// 原始代码
console.log(window.foo);

// 转换后
;(function(){
  with(this){
    const {console,document,...} = this;  // 优化常用变量
    console.log(window.foo);
  }
}).bind(window.__compartment_globalThis__0__)();

// 执行时：
// 1. this 指向沙箱的 globalThis（Proxy）
// 2. with(this) 使得变量查找先从 this 开始
// 3. window.foo 实际访问的是 Proxy.foo
```

## 副作用补丁（Patchers）

### 启动阶段补丁

```typescript
// packages/sandbox/src/patchers/index.ts
export function patchAtBootstrapping(
  appName: string,
  getContainer: () => HTMLElement,
  opts: SandboxConfig,
): Free[] {
  return [
    // 动态样式/脚本注入补丁
    patchDynamicAppend(appName, getContainer, opts),
  ].filter(Boolean) as Free[];
}
```

### 挂载阶段补丁

```typescript
export function patchAtMounting(
  appName: string,
  getContainer: () => HTMLElement,
  opts: SandboxConfig,
): Free[] {
  return [
    // 事件监听补丁
    patchWindowListener(opts.sandbox),
    // 定时器补丁
    patchInterval(opts.sandbox),
    // History 监听补丁
    patchHistoryListener(opts.sandbox),
  ].filter(Boolean) as Free[];
}
```

### 事件监听补丁

```typescript
// packages/sandbox/src/patchers/windowListener.ts
export function patchWindowListener(sandbox: Sandbox): Free {
  const listeners = new Map<string, Set<EventListener>>();
  const { globalThis } = sandbox;

  const rawAddEventListener = globalThis.addEventListener;
  const rawRemoveEventListener = globalThis.removeEventListener;

  globalThis.addEventListener = function(type: string, listener: EventListener, options?: boolean | AddEventListenerOptions) {
    // 记录监听器
    if (!listeners.has(type)) {
      listeners.set(type, new Set());
    }
    listeners.get(type)!.add(listener);

    return rawAddEventListener.call(this, type, listener, options);
  };

  globalThis.removeEventListener = function(type: string, listener: EventListener, options?: boolean | EventListenerOptions) {
    listeners.get(type)?.delete(listener);
    return rawRemoveEventListener.call(this, type, listener, options);
  };

  // 返回清理函数
  return function free(): Rebuild {
    // 移除所有监听器
    listeners.forEach((listenerSet, type) => {
      listenerSet.forEach((listener) => {
        rawRemoveEventListener.call(globalThis, type, listener);
      });
    });

    // 恢复原始方法
    globalThis.addEventListener = rawAddEventListener;
    globalThis.removeEventListener = rawRemoveEventListener;

    // 返回重建函数
    return function rebuild() {
      globalThis.addEventListener = function(...args) { /* ... */ };
      globalThis.removeEventListener = function(...args) { /* ... */ };
      
      // 重新添加监听器
      listeners.forEach((listenerSet, type) => {
        listenerSet.forEach((listener) => {
          rawAddEventListener.call(globalThis, type, listener);
        });
      });
    };
  };
}
```

### 定时器补丁

```typescript
// packages/sandbox/src/patchers/interval.ts
export function patchInterval(sandbox: Sandbox): Free {
  const intervals = new Set<number>();
  const { globalThis } = sandbox;

  const rawSetInterval = globalThis.setInterval;
  const rawClearInterval = globalThis.clearInterval;

  globalThis.setInterval = function(handler: TimerHandler, timeout?: number, ...args: unknown[]) {
    const intervalId = rawSetInterval.call(this, handler, timeout, ...args);
    intervals.add(intervalId);
    return intervalId;
  };

  globalThis.clearInterval = function(intervalId: number) {
    intervals.delete(intervalId);
    return rawClearInterval.call(this, intervalId);
  };

  return function free(): Rebuild {
    // 清除所有定时器
    intervals.forEach((id) => rawClearInterval.call(globalThis, id));
    intervals.clear();

    globalThis.setInterval = rawSetInterval;
    globalThis.clearInterval = rawClearInterval;

    return function rebuild() {
      // 定时器不需要重建
    };
  };
}
```

## 沙箱生命周期

```
┌─────────────────────────────────────────────────────────────────┐
│                      沙箱生命周期                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   创建 ──▶ 启动补丁 ──▶ active() ──▶ 挂载补丁                    │
│                           │                                      │
│                           ▼                                      │
│                      子应用运行                                   │
│                           │                                      │
│                           ▼                                      │
│                      inactive()                                  │
│                           │                                      │
│                           ▼                                      │
│              记录副作用 + 清理补丁                                │
│                           │                                      │
│                           ▼                                      │
│              (下次 mount 时恢复副作用)                            │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## 小结

Qiankun 3.0 沙箱的核心设计：

1. **Membrane 模式**：通过 Proxy 代理实现属性隔离
2. **Compartment**：使用 with 语句绑定代码执行作用域
3. **副作用管理**：补丁机制记录和恢复事件监听、定时器等
4. **锁定机制**：inactive 时锁定沙箱，防止意外修改

---

> 下一篇：应用加载
