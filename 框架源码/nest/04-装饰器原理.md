# NestJS æºç è§£æï¼šè£…é¥°å™¨åŸç†

> æ·±å…¥ TypeScript è£…é¥°å™¨å’Œ reflect-metadataï¼Œæ­ç§˜ NestJS çš„å…ƒæ•°æ®é©±åŠ¨è®¾è®¡ã€‚

## è£…é¥°å™¨åŸºç¡€

TypeScript è£…é¥°å™¨æ˜¯ä¸€ç§ç‰¹æ®Šçš„å£°æ˜ï¼Œå¯ä»¥é™„åŠ åˆ°ç±»ã€æ–¹æ³•ã€å±æ€§æˆ–å‚æ•°ä¸Šã€‚

### ç±»è£…é¥°å™¨

```typescript
function Controller(prefix: string): ClassDecorator {
  return (target: Function) => {
    Reflect.defineMetadata('path', prefix, target);
  };
}

@Controller('cats')
class CatsController {}
```

### æ–¹æ³•è£…é¥°å™¨

```typescript
function Get(path: string): MethodDecorator {
  return (target, key, descriptor) => {
    Reflect.defineMetadata('path', path, descriptor.value);
    Reflect.defineMetadata('method', 'GET', descriptor.value);
  };
}

class CatsController {
  @Get('all')
  findAll() {}
}
```

### å‚æ•°è£…é¥°å™¨

```typescript
function Body(): ParameterDecorator {
  return (target, key, index) => {
    const existingParams = Reflect.getMetadata('params', target, key) || [];
    existingParams.push({ index, type: 'body' });
    Reflect.defineMetadata('params', existingParams, target, key);
  };
}

class CatsController {
  create(@Body() dto: CreateCatDto) {}
}
```

## NestJS æ ¸å¿ƒè£…é¥°å™¨

### @Injectable

```typescript
// packages/common/decorators/core/injectable.decorator.ts
export function Injectable(options?: InjectableOptions): ClassDecorator {
  return (target: object) => {
    // æ ‡è®°ä¸ºå¯æ³¨å…¥
    Reflect.defineMetadata(INJECTABLE_WATERMARK, true, target);
    // å­˜å‚¨ä½œç”¨åŸŸé€‰é¡¹
    Reflect.defineMetadata(SCOPE_OPTIONS_METADATA, options, target);
  };
}
```

### @Controller

```typescript
// packages/common/decorators/core/controller.decorator.ts
export function Controller(prefixOrOptions?: string | ControllerOptions): ClassDecorator {
  const defaultPath = '/';

  const [path, host, scopeOptions, versionOptions] = isUndefined(prefixOrOptions)
    ? [defaultPath, undefined, undefined, undefined]
    : isString(prefixOrOptions)
      ? [prefixOrOptions, undefined, undefined, undefined]
      : [
          prefixOrOptions.path || defaultPath,
          prefixOrOptions.host,
          { scope: prefixOrOptions.scope, durable: prefixOrOptions.durable },
          { version: prefixOrOptions.version },
        ];

  return (target: object) => {
    // æ ‡è®°ä¸ºæ§åˆ¶å™¨
    Reflect.defineMetadata(CONTROLLER_WATERMARK, true, target);
    // å­˜å‚¨è·¯å¾„
    Reflect.defineMetadata(PATH_METADATA, path, target);
    // å­˜å‚¨ä¸»æœº
    Reflect.defineMetadata(HOST_METADATA, host, target);
    // å­˜å‚¨ä½œç”¨åŸŸ
    Reflect.defineMetadata(SCOPE_OPTIONS_METADATA, scopeOptions, target);
    // å­˜å‚¨ç‰ˆæœ¬
    Reflect.defineMetadata(VERSION_METADATA, versionOptions?.version, target);
  };
}
```

### @Get/@Post ç­‰

```typescript
// packages/common/decorators/http/request-mapping.decorator.ts
const createMappingDecorator = (method: RequestMethod) => (path?: string): MethodDecorator => {
  return (target, key, descriptor) => {
    Reflect.defineMetadata(PATH_METADATA, path || '/', descriptor.value);
    Reflect.defineMetadata(METHOD_METADATA, method, descriptor.value);
    return descriptor;
  };
};

export const Get = createMappingDecorator(RequestMethod.GET);
export const Post = createMappingDecorator(RequestMethod.POST);
export const Put = createMappingDecorator(RequestMethod.PUT);
export const Delete = createMappingDecorator(RequestMethod.DELETE);
export const Patch = createMappingDecorator(RequestMethod.PATCH);
```

### @Inject

```typescript
// packages/common/decorators/core/inject.decorator.ts
export function Inject<T = any>(token?: T): PropertyDecorator & ParameterDecorator {
  return (target: object, key: string | symbol | undefined, index?: number) => {
    const type = token || Reflect.getMetadata('design:type', target, key!);

    if (!isUndefined(index)) {
      // å‚æ•°æ³¨å…¥
      let dependencies = Reflect.getMetadata(SELF_DECLARED_DEPS_METADATA, target) || [];
      dependencies = [...dependencies, { index, param: type }];
      Reflect.defineMetadata(SELF_DECLARED_DEPS_METADATA, dependencies, target);
    } else {
      // å±æ€§æ³¨å…¥
      let properties = Reflect.getMetadata(PROPERTY_DEPS_METADATA, target.constructor) || [];
      properties = [...properties, { key, type }];
      Reflect.defineMetadata(PROPERTY_DEPS_METADATA, properties, target.constructor);
    }
  };
}
```

## å‚æ•°è£…é¥°å™¨

### @Body/@Query/@Param

```typescript
// packages/common/decorators/http/route-params.decorator.ts
function createRouteParamDecorator(paramtype: RouteParamtypes) {
  return (data?: any): ParameterDecorator =>
    (target, key, index) => {
      const args = Reflect.getMetadata(ROUTE_ARGS_METADATA, target.constructor, key) || {};

      Reflect.defineMetadata(
        ROUTE_ARGS_METADATA,
        {
          ...args,
          [`${paramtype}:${index}`]: {
            index,
            data,
            pipes: [],
          },
        },
        target.constructor,
        key,
      );
    };
}

export const Body = createRouteParamDecorator(RouteParamtypes.BODY);
export const Query = createRouteParamDecorator(RouteParamtypes.QUERY);
export const Param = createRouteParamDecorator(RouteParamtypes.PARAM);
export const Headers = createRouteParamDecorator(RouteParamtypes.HEADERS);
export const Req = createRouteParamDecorator(RouteParamtypes.REQUEST);
export const Res = createRouteParamDecorator(RouteParamtypes.RESPONSE);
```

## å¢å¼ºå™¨è£…é¥°å™¨

### @UseGuards

```typescript
// packages/common/decorators/core/use-guards.decorator.ts
export function UseGuards(...guards: (CanActivate | Function)[]): MethodDecorator & ClassDecorator {
  return (
    target: any,
    key?: string | symbol,
    descriptor?: TypedPropertyDescriptor<any>,
  ) => {
    const isMethodDecorator = !!descriptor;

    if (isMethodDecorator) {
      // æ–¹æ³•çº§åˆ«
      const existingGuards = Reflect.getMetadata(GUARDS_METADATA, descriptor.value) || [];
      Reflect.defineMetadata(GUARDS_METADATA, [...guards, ...existingGuards], descriptor.value);
    } else {
      // ç±»çº§åˆ«
      const existingGuards = Reflect.getMetadata(GUARDS_METADATA, target) || [];
      Reflect.defineMetadata(GUARDS_METADATA, [...guards, ...existingGuards], target);
    }

    return descriptor;
  };
}
```

### @UsePipes/@UseInterceptors/@UseFilters

å®ç°ç±»ä¼¼ï¼Œéƒ½æ˜¯å°†å¢å¼ºå™¨å­˜å‚¨åˆ°å…ƒæ•°æ®ä¸­ã€‚

## å…ƒæ•°æ®è¯»å–

### MetadataScanner

æ‰«æç±»çš„æ‰€æœ‰æ–¹æ³•ï¼š

```typescript
// packages/core/metadata-scanner.ts
export class MetadataScanner {
  public scanFromPrototype<T, R = any>(
    instance: T,
    prototype: object,
    callback: (name: string) => R,
  ): R[] {
    const methodNames = this.getAllMethodNames(prototype);
    return methodNames.map(callback);
  }

  public getAllMethodNames(prototype: object): string[] {
    const isMethod = (prop: string) => {
      const descriptor = Object.getOwnPropertyDescriptor(prototype, prop);
      return !descriptor?.get && !descriptor?.set && isFunction(prototype[prop]);
    };

    return Object.getOwnPropertyNames(prototype).filter(
      prop => prop !== 'constructor' && isMethod(prop),
    );
  }
}
```

### PathsExplorer

æ¢ç´¢æ§åˆ¶å™¨çš„è·¯ç”±ï¼š

```typescript
// packages/core/router/paths-explorer.ts
export class PathsExplorer {
  public scanForPaths(instance: Controller): RouteDefinition[] {
    const prototype = Object.getPrototypeOf(instance);

    return this.metadataScanner.scanFromPrototype(instance, prototype, method => {
      const path = Reflect.getMetadata(PATH_METADATA, prototype[method]);
      const requestMethod = Reflect.getMetadata(METHOD_METADATA, prototype[method]);

      return {
        path: this.validatePath(path),
        requestMethod,
        targetCallback: prototype[method],
        methodName: method,
      };
    });
  }
}
```

## è‡ªå®šä¹‰è£…é¥°å™¨

### ç»„åˆè£…é¥°å™¨

```typescript
import { applyDecorators, SetMetadata, UseGuards } from '@nestjs/common';

export function Auth(...roles: string[]) {
  return applyDecorators(
    SetMetadata('roles', roles),
    UseGuards(AuthGuard, RolesGuard),
  );
}

// ä½¿ç”¨
@Auth('admin')
@Get()
findAll() {}
```

### applyDecorators å®ç°

```typescript
// packages/common/decorators/core/apply-decorators.ts
export function applyDecorators(
  ...decorators: Array<ClassDecorator | MethodDecorator | PropertyDecorator>
) {
  return <TFunction extends Function, Y>(
    target: TFunction | object,
    propertyKey?: string | symbol,
    descriptor?: TypedPropertyDescriptor<Y>,
  ) => {
    for (const decorator of decorators) {
      if (target instanceof Function && !descriptor) {
        (decorator as ClassDecorator)(target);
        continue;
      }
      (decorator as MethodDecorator | PropertyDecorator)(
        target,
        propertyKey!,
        descriptor!,
      );
    }
  };
}
```

### è‡ªå®šä¹‰å‚æ•°è£…é¥°å™¨

```typescript
import { createParamDecorator, ExecutionContext } from '@nestjs/common';

export const User = createParamDecorator(
  (data: string, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    const user = request.user;
    return data ? user?.[data] : user;
  },
);

// ä½¿ç”¨
@Get()
findOne(@User('id') userId: string) {}
```

### createParamDecorator å®ç°

```typescript
// packages/common/decorators/http/create-route-param-metadata.decorator.ts
export function createParamDecorator<T = any, I = any, O = any>(
  factory: CustomParamFactory<T, I, O>,
): (...dataOrPipes: (Type<PipeTransform> | PipeTransform | T)[]) => ParameterDecorator {
  return (...dataOrPipes: (Type<PipeTransform> | PipeTransform | T)[]): ParameterDecorator => {
    const [data, ...pipes] = dataOrPipes;

    return (target, key, index) => {
      const args = Reflect.getMetadata(ROUTE_ARGS_METADATA, target.constructor, key) || {};

      const paramtype = uid(21);
      Reflect.defineMetadata(
        ROUTE_ARGS_METADATA,
        {
          ...args,
          [`${paramtype}:${index}`]: {
            index,
            factory,
            data,
            pipes,
          },
        },
        target.constructor,
        key,
      );
    };
  };
}
```

## å…ƒæ•°æ®å¸¸é‡

```typescript
// packages/common/constants.ts
export const MODULE_METADATA = {
  IMPORTS: 'imports',
  PROVIDERS: 'providers',
  CONTROLLERS: 'controllers',
  EXPORTS: 'exports',
};

export const PATH_METADATA = 'path';
export const METHOD_METADATA = 'method';
export const ROUTE_ARGS_METADATA = '__routeArguments__';
export const GUARDS_METADATA = '__guards__';
export const INTERCEPTORS_METADATA = '__interceptors__';
export const PIPES_METADATA = '__pipes__';
export const EXCEPTION_FILTERS_METADATA = '__exceptionFilters__';
export const INJECTABLE_WATERMARK = '__injectable__';
export const CONTROLLER_WATERMARK = '__controller__';
```

## æ€»ç»“

NestJS è£…é¥°å™¨ç³»ç»Ÿçš„æ ¸å¿ƒï¼š

1. **reflect-metadata**ï¼šå­˜å‚¨å’Œè¯»å–å…ƒæ•°æ®
2. **ç±»è£…é¥°å™¨**ï¼šæ ‡è®°ç±»çš„è§’è‰²ï¼ˆControllerã€Injectableï¼‰
3. **æ–¹æ³•è£…é¥°å™¨**ï¼šå®šä¹‰è·¯ç”±å’Œå¢å¼ºå™¨
4. **å‚æ•°è£…é¥°å™¨**ï¼šå®šä¹‰å‚æ•°æ¥æº
5. **ç»„åˆè£…é¥°å™¨**ï¼šapplyDecorators ç»„åˆå¤šä¸ªè£…é¥°å™¨
6. **è‡ªå®šä¹‰è£…é¥°å™¨**ï¼šcreateParamDecorator åˆ›å»ºå‚æ•°è£…é¥°å™¨

ä¸‹ä¸€ç¯‡æˆ‘ä»¬å°†åˆ†æè·¯ç”±ç³»ç»Ÿçš„å®ç°ã€‚

---

> ğŸ“¦ æºç ä½ç½®ï¼š`packages/common/decorators/`
>
> ä¸‹ä¸€ç¯‡ï¼šNestJS è·¯ç”±ç³»ç»Ÿ
