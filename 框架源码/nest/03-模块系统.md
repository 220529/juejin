# NestJS æºç è§£æï¼šæ¨¡å—ç³»ç»Ÿ

> æ·±å…¥ @Module è£…é¥°å™¨å’Œ DependenciesScannerï¼Œæ­ç§˜æ¨¡å—çš„æ‰«æä¸åŠ è½½ã€‚

## @Module è£…é¥°å™¨

æ¨¡å—æ˜¯ NestJS ç»„ç»‡ä»£ç çš„åŸºæœ¬å•å…ƒï¼š

```typescript
@Module({
  imports: [DatabaseModule],
  controllers: [CatsController],
  providers: [CatsService],
  exports: [CatsService],
})
export class CatsModule {}
```

### è£…é¥°å™¨å®ç°

```typescript
// packages/common/decorators/modules/module.decorator.ts
export function Module(metadata: ModuleMetadata): ClassDecorator {
  const propsKeys = Object.keys(metadata);
  validateModuleKeys(propsKeys);

  return (target: Function) => {
    for (const property in metadata) {
      if (Object.hasOwnProperty.call(metadata, property)) {
        Reflect.defineMetadata(property, (metadata as any)[property], target);
      }
    }
  };
}
```

æœ¬è´¨å°±æ˜¯å°†é…ç½®å­˜å‚¨åˆ°ç±»çš„å…ƒæ•°æ®ä¸­ï¼š

```typescript
Reflect.defineMetadata('imports', [DatabaseModule], CatsModule);
Reflect.defineMetadata('controllers', [CatsController], CatsModule);
Reflect.defineMetadata('providers', [CatsService], CatsModule);
Reflect.defineMetadata('exports', [CatsService], CatsModule);
```

## æ¨¡å—æ‰«æ

### DependenciesScanner

```typescript
// packages/core/scanner.ts
export class DependenciesScanner {
  public async scan(module: ModuleDefinition, options?: { overrides?: ModuleOverride[] }) {
    // 1. æ³¨å†Œæ ¸å¿ƒæ¨¡å—
    await this.registerCoreModule(options?.overrides);

    // 2. é€’å½’æ‰«ææ¨¡å—
    await this.scanForModules({
      moduleDefinition: module,
      overrides: options?.overrides,
    });

    // 3. æ‰«ææ¨¡å—å†…çš„ä¾èµ–
    await this.scanModulesForDependencies();

    // 4. è®¡ç®—æ¨¡å—è·ç¦»
    this.calculateModulesDistance();
  }
}
```

### é€’å½’æ‰«ææ¨¡å—

```typescript
public async scanForModules({
  moduleDefinition,
  scope = [],
  ctxRegistry = [],
  overrides = [],
  lazy,
}: ModulesScanParameters): Promise<Module[]> {
  // æ·»åŠ æ¨¡å—åˆ°å®¹å™¨
  const { moduleRef, inserted } = (await this.container.addModule(
    moduleDefinition,
    scope,
  ))!;

  if (!inserted) {
    return [moduleRef];
  }

  // è·å– imports
  const importedModules = this.reflectImports(moduleDefinition);

  // é€’å½’æ‰«æ imports
  const modules = await this.scanModulesRecursively(
    importedModules,
    [].concat(scope, moduleDefinition),
    ctxRegistry,
    overrides,
  );

  return [moduleRef].concat(modules);
}

// åå°„è·å– imports
public reflectImports(module: Type<any>): Type<any>[] {
  return Reflect.getMetadata(MODULE_METADATA.IMPORTS, module) || [];
}
```

### æ‰«ææ¨¡å—ä¾èµ–

```typescript
public async scanModulesForDependencies(
  modules: Map<string, Module> = this.container.getModules(),
) {
  for (const [token, moduleRef] of modules) {
    // æ‰«æ imports
    await this.reflectImports(moduleRef.metatype).forEach(imported =>
      this.insertImport(imported, token),
    );

    // æ‰«æ providers
    this.reflectProviders(moduleRef.metatype).forEach(provider =>
      this.insertProvider(provider, token),
    );

    // æ‰«æ controllers
    this.reflectControllers(moduleRef.metatype).forEach(controller =>
      this.insertController(controller, token),
    );

    // æ‰«æ exports
    this.reflectExports(moduleRef.metatype).forEach(exported =>
      this.insertExportedProvider(exported, token),
    );
  }
}
```

## æ¨¡å—ç±»å‹

### é™æ€æ¨¡å—

```typescript
@Module({
  providers: [CatsService],
})
export class CatsModule {}
```

### åŠ¨æ€æ¨¡å—

```typescript
@Module({})
export class DatabaseModule {
  static forRoot(options: DatabaseOptions): DynamicModule {
    return {
      module: DatabaseModule,
      providers: [
        {
          provide: 'DATABASE_OPTIONS',
          useValue: options,
        },
        DatabaseService,
      ],
      exports: [DatabaseService],
    };
  }
}

// ä½¿ç”¨
@Module({
  imports: [DatabaseModule.forRoot({ host: 'localhost' })],
})
export class AppModule {}
```

åŠ¨æ€æ¨¡å—å¤„ç†ï¼š

```typescript
// packages/core/injector/compiler.ts
export class ModuleCompiler {
  public async compile(metatype: ModuleMetatype): Promise<ModuleFactory> {
    // å¤„ç† Promise
    const unwrappedMetatype = await this.extractMetadata(metatype);

    // å¤„ç†åŠ¨æ€æ¨¡å—
    const { type, dynamicMetadata } = this.isDynamicModule(unwrappedMetatype)
      ? this.extractDynamicMetadata(unwrappedMetatype)
      : { type: unwrappedMetatype, dynamicMetadata: undefined };

    // ç”Ÿæˆå”¯ä¸€ token
    const token = this.moduleOpaqueKeyFactory.create(type, dynamicMetadata);

    return { type, dynamicMetadata, token };
  }
}
```

### å…¨å±€æ¨¡å—

```typescript
@Global()
@Module({
  providers: [ConfigService],
  exports: [ConfigService],
})
export class ConfigModule {}
```

å…¨å±€æ¨¡å—çš„ exports å¯¹æ‰€æœ‰æ¨¡å—å¯è§ï¼š

```typescript
// packages/core/injector/container.ts
public addGlobalModule(module: Module) {
  this.globalModules.add(module);
}

// packages/core/injector/injector.ts
public async lookupComponentInGlobalModules(
  dependency: InjectorDependency,
  contextId: ContextId,
  wrapper: InstanceWrapper,
) {
  for (const globalModule of this.container.getGlobalModules()) {
    const provider = globalModule.providers.get(dependency);
    if (provider) {
      return provider;
    }
  }
  return null;
}
```

## æ¨¡å—å¯¼å…¥å¯¼å‡º

### imports

å¯¼å…¥å…¶ä»–æ¨¡å—ï¼Œä½¿å…¶ exports å¯ç”¨ï¼š

```typescript
@Module({
  imports: [DatabaseModule],
})
export class CatsModule {}
```

### exports

å¯¼å‡º providersï¼Œä½¿å…¶å¯¹å¯¼å…¥æ–¹å¯ç”¨ï¼š

```typescript
@Module({
  providers: [CatsService, DogsService],
  exports: [CatsService], // åªå¯¼å‡º CatsService
})
export class PetsModule {}
```

å¯¼å‡ºå¤„ç†ï¼š

```typescript
// packages/core/injector/module.ts
public addExportedProvider(provider: InjectionToken) {
  this._exports.add(provider);
}

// æŸ¥æ‰¾å¯¼å‡ºçš„ provider
public getProviderByKey<T = any>(name: InjectionToken): InstanceWrapper<T> {
  // å…ˆåœ¨è‡ªå·±çš„ providers ä¸­æ‰¾
  if (this._providers.has(name)) {
    return this._providers.get(name) as InstanceWrapper<T>;
  }

  // å†åœ¨ imports çš„æ¨¡å—ä¸­æ‰¾
  for (const importedModule of this._imports) {
    if (importedModule.exports.has(name)) {
      return importedModule.getProviderByKey(name);
    }
  }

  return null;
}
```

## æ¨¡å—è·ç¦»è®¡ç®—

ç”¨äºç¡®å®šä¾èµ–è§£æé¡ºåºï¼Œæºç ä½¿ç”¨ `TopologyTree` å®ç°ï¼š

```typescript
// packages/core/scanner.ts
public calculateModulesDistance() {
  const modulesGenerator = this.container.getModules().values();
  // è·³è¿‡ InternalCoreModule
  modulesGenerator.next();

  const rootModule = modulesGenerator.next().value!;
  if (!rootModule) {
    return;
  }

  // ä½¿ç”¨æ‹“æ‰‘æ ‘è®¡ç®—æ¨¡å—è·ç¦»
  const tree = new TopologyTree(rootModule);
  tree.walk((moduleRef, depth) => {
    if (moduleRef.isGlobal) {
      return; // å…¨å±€æ¨¡å—è·ç¦»ä¸º MAX_VALUE
    }
    moduleRef.distance = depth;
  });
}
```

æ¨¡å—è·ç¦»å½±å“ï¼š
- **ä¸­é—´ä»¶æ³¨å†Œé¡ºåº**ï¼šè·ç¦»å°çš„æ¨¡å—å…ˆæ³¨å†Œ
- **å…¨å±€æ¨¡å—**ï¼šè·ç¦»ä¸º `Number.MAX_VALUE`ï¼Œæœ€åå¤„ç†
```

## æ¨¡å—ç”Ÿå‘½å‘¨æœŸ

```typescript
export interface NestModule {
  configure(consumer: MiddlewareConsumer): void;
}

@Module({})
export class CatsModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply(LoggerMiddleware)
      .forRoutes(CatsController);
  }
}
```

configure æ–¹æ³•åœ¨æ¨¡å—åˆå§‹åŒ–æ—¶è°ƒç”¨ï¼š

```typescript
// packages/core/middleware/middleware-module.ts
public async register(
  middlewareContainer: MiddlewareContainer,
  container: NestContainer,
  config: ApplicationConfig,
  injector: Injector,
  httpAdapter: HttpServer,
  graphInspector: GraphInspector,
) {
  const modules = container.getModules();

  for (const [token, moduleRef] of modules) {
    const instance = moduleRef.instance;

    // è°ƒç”¨ configure æ–¹æ³•
    if (instance && isFunction(instance.configure)) {
      const middlewareBuilder = new MiddlewareBuilder(
        this.routesMapper,
        httpAdapter,
        this.routeInfoPathExtractor,
      );

      await instance.configure(middlewareBuilder);

      // æ”¶é›†ä¸­é—´ä»¶é…ç½®
      const middlewareConfigs = middlewareBuilder.build();
      middlewareContainer.insertConfig(middlewareConfigs, token);
    }
  }
}
```

## æ¨¡å—é‡æ–°å¯¼å‡º

å¯ä»¥é‡æ–°å¯¼å‡ºå¯¼å…¥çš„æ¨¡å—ï¼š

```typescript
@Module({
  imports: [DatabaseModule],
  exports: [DatabaseModule], // é‡æ–°å¯¼å‡º
})
export class SharedModule {}
```

## æ€»ç»“

NestJS æ¨¡å—ç³»ç»Ÿçš„æ ¸å¿ƒï¼š

1. **@Module è£…é¥°å™¨**ï¼šå°†é…ç½®å­˜å‚¨åˆ°å…ƒæ•°æ®
2. **DependenciesScanner**ï¼šé€’å½’æ‰«ææ¨¡å—ä¾èµ–æ ‘
3. **åŠ¨æ€æ¨¡å—**ï¼šè¿è¡Œæ—¶é…ç½®æ¨¡å—
4. **å…¨å±€æ¨¡å—**ï¼šexports å¯¹æ‰€æœ‰æ¨¡å—å¯è§
5. **imports/exports**ï¼šæ§åˆ¶ä¾èµ–å¯è§æ€§
6. **æ¨¡å—è·ç¦»**ï¼šç¡®å®šä¾èµ–è§£æé¡ºåº

ä¸‹ä¸€ç¯‡æˆ‘ä»¬å°†åˆ†æè£…é¥°å™¨çš„å®ç°åŸç†ã€‚

---

> ğŸ“¦ æºç ä½ç½®ï¼š`packages/core/scanner.ts`ã€`packages/common/decorators/modules/`
>
> ä¸‹ä¸€ç¯‡ï¼šNestJS è£…é¥°å™¨åŸç†
